<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Strings and Characters</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="strings-and-characters">
<h1>Strings and Characters</h1>
<p>A <em>string</em> is a series of characters, such as <code class="docutils literal notranslate"><span class="pre">&quot;hello,</span> <span class="pre">world&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;albatross&quot;</span></code>. Swift strings are represented by the <code class="docutils literal notranslate"><span class="pre">String</span></code> type. The contents of a <code class="docutils literal notranslate"><span class="pre">String</span></code> can be accessed in various ways, including as a collection of <code class="docutils literal notranslate"><span class="pre">Character</span></code> values.</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Character</span></code> types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that’s similar to C. String concatenation is as simple as combining two strings with the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift. You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing.</p>
<p>Despite this simplicity of syntax, Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is bridged with Foundation’s <code class="docutils literal notranslate"><span class="pre">NSString</span></code> class. Foundation also extends <code class="docutils literal notranslate"><span class="pre">String</span></code> to expose methods defined by <code class="docutils literal notranslate"><span class="pre">NSString</span></code>. This means, if you import Foundation, you can access those <code class="docutils literal notranslate"><span class="pre">NSString</span></code> methods on <code class="docutils literal notranslate"><span class="pre">String</span></code> without casting.</p>
<p>For more information about using <code class="docutils literal notranslate"><span class="pre">String</span></code> with Foundation and Cocoa, see <a class="reference external" href="https://developer.apple.com/documentation/swift/string#2919514">Bridging Between String and NSString</a><span class="link-target"> [https://developer.apple.com/documentation/swift/string#2919514]</span>.</p>
</div>
<div class="section" id="ID286">
<h2>String Literals</h2>
<p>You can include predefined <code class="docutils literal notranslate"><span class="pre">String</span></code> values within your code as <em>string literals</em>. A string literal is a sequence of characters surrounded by double quotation marks (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>).</p>
<p>Use a string literal as an initial value for a constant or variable:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someString</span> = <span class="s">&quot;Some string literal value&quot;</span>
</li></ol></div></div></div>
<p>Note that Swift infers a type of <code class="docutils literal notranslate"><span class="pre">String</span></code> for the <code class="docutils literal notranslate"><span class="pre">someString</span></code> constant because it’s initialized with a string literal value.</p>
<div class="section" id="ID564">
<h3>Multiline String Literals</h3>
<p>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">quotation</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span>
</li><li><span class="s">please your Majesty?&quot; he asked.</span>
</li><li>
</li><li><span class="s">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span>
</li><li><span class="s">till you come to the end; then stop.&quot;</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li></ol></div></div></div>
<p>A multiline string literal includes all of the lines between its opening and closing quotation marks. The string begins on the first line after the opening quotation marks (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code>) and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">singleLineString</span> = <span class="s">&quot;These are the same.&quot;</span>
</li><li><span class="k">let</span> <span class="nv">multilineString</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">These are the same.</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li></ol></div></div></div>
<p>When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value. If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>) at the end of those lines:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">softWrappedQuotation</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">The White Rabbit put on his spectacles.  &quot;Where shall I begin, \</span>
</li><li><span class="s">please your Majesty?&quot; he asked.</span>
</li><li>
</li><li><span class="s">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on \</span>
</li><li><span class="s">till you come to the end; then stop.&quot;</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li></ol></div></div></div>
<p>To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">lineBreaks</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li>
</li><li><span class="s">This string starts with a line break.</span>
</li><li><span class="s">It also ends with a line break.</span>
</li><li>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li></ol></div></div></div>
<p>A multiline string can be indented to match the surrounding code. The whitespace before the closing quotation marks (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code>) tells Swift what whitespace to ignore before all of the other lines. However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotation marks, that whitespace <em>is</em> included.</p>
<img alt="../_images/multilineStringWhitespace_2x.png" class="align-center" src="../_images/multilineStringWhitespace_2x.png" style="width: 519.0px;" />
<p>In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace. The middle line has more indentation than the closing quotation marks, so it starts with that extra four-space indentation.</p>
</div>
<div class="section" id="ID295">
<h3>Special Characters in String Literals</h3>
<p>String literals can include the following special characters:</p>
<ul class="simple">
<li><p>The escaped special characters <code class="docutils literal notranslate"><span class="pre">\0</span></code> (null character), <code class="docutils literal notranslate"><span class="pre">\\</span></code> (backslash), <code class="docutils literal notranslate"><span class="pre">\t</span></code> (horizontal tab), <code class="docutils literal notranslate"><span class="pre">\n</span></code> (line feed), <code class="docutils literal notranslate"><span class="pre">\r</span></code> (carriage return), <code class="docutils literal notranslate"><span class="pre">\&quot;</span></code> (double quotation mark) and <code class="docutils literal notranslate"><span class="pre">\'</span></code> (single quotation mark)</p></li>
<li><p>An arbitrary Unicode scalar value, written as <code class="docutils literal notranslate"><span class="pre">\u{</span></code><em>n</em><code class="docutils literal notranslate"><span class="pre">}</span></code>, where <em>n</em> is a 1–8 digit hexadecimal number (Unicode is discussed in <a class="reference internal" href="#ID293"><span class="std std-ref">Unicode</span></a> below)</p></li>
</ul>
<p>The code below shows four examples of these special characters. The <code class="docutils literal notranslate"><span class="pre">wiseWords</span></code> constant contains two escaped double quotation marks. The <code class="docutils literal notranslate"><span class="pre">dollarSign</span></code>, <code class="docutils literal notranslate"><span class="pre">blackHeart</span></code>, and <code class="docutils literal notranslate"><span class="pre">sparklingHeart</span></code> constants demonstrate the Unicode scalar format:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">wiseWords</span> = <span class="s">&quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;</span>
</li><li><span class="c">// &quot;Imagination is more important than knowledge&quot; - Einstein</span>
</li><li><span class="k">let</span> <span class="nv">dollarSign</span> = <span class="s">&quot;\u{24}&quot;</span>        <span class="c">// $,  Unicode scalar U+0024</span>
</li><li><span class="k">let</span> <span class="nv">blackHeart</span> = <span class="s">&quot;\u{2665}&quot;</span>      <span class="c">// ♥,  Unicode scalar U+2665</span>
</li><li><span class="k">let</span> <span class="nv">sparklingHeart</span> = <span class="s">&quot;\u{1F496}&quot;</span> <span class="c">// 💖, Unicode scalar U+1F496</span>
</li></ol></div></div></div>
<p>Because multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>) inside of a multiline string literal without escaping it. To include the text <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code> in a multiline string, escape at least one of the quotation marks. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">threeDoubleQuotationMarks</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">Escaping the first quotation mark \&quot;&quot;&quot;</span>
</li><li><span class="s">Escaping all three quotation marks \&quot;\&quot;\&quot;</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID606">
<h3>Extended String Delimiters</h3>
<p>You can place a string literal within <em>extended delimiters</em> to include special characters in a string without invoking their effect. You place your string within quotation marks (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>) and surround that with number signs (<code class="docutils literal notranslate"><span class="pre">#</span></code>). For example, printing the string literal <code class="docutils literal notranslate"><span class="pre">#&quot;Line</span> <span class="pre">1\nLine</span> <span class="pre">2&quot;#</span></code> prints the line feed escape sequence (<code class="docutils literal notranslate"><span class="pre">\n</span></code>) rather than printing the string across two lines.</p>
<p>If you need the special effects of a character in a string literal, match the number of number signs within the string following the escape character (<code class="docutils literal notranslate"><span class="pre">\</span></code>). For example, if your string is <code class="docutils literal notranslate"><span class="pre">#&quot;Line</span> <span class="pre">1\nLine</span> <span class="pre">2&quot;#</span></code> and you want to break the line, you can use <code class="docutils literal notranslate"><span class="pre">#&quot;Line</span> <span class="pre">1\#nLine</span> <span class="pre">2&quot;#</span></code> instead. Similarly, <code class="docutils literal notranslate"><span class="pre">###&quot;Line1\###nLine2&quot;###</span></code> also breaks the line.</p>
<p>String literals created using extended delimiters can also be multiline string literals. You can use extended delimiters to include the text <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code> in a multiline string, overriding the default behavior that ends the literal. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">threeMoreDoubleQuotationMarks</span> = <span class="s">#&quot;&quot;&quot;</span>
</li><li><span class="s">Here are three more double quotes: &quot;&quot;&quot;</span>
</li><li><span class="s">&quot;&quot;&quot;#</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID287">
<h2>Initializing an Empty String</h2>
<p>To create an empty <code class="docutils literal notranslate"><span class="pre">String</span></code> value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new <code class="docutils literal notranslate"><span class="pre">String</span></code> instance with initializer syntax:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">emptyString</span> = <span class="s">&quot;&quot;</span>               <span class="c">// empty string literal</span>
</li><li><span class="k">var</span> <span class="nv">anotherEmptyString</span> = <span class="nv">String</span>()  <span class="c">// initializer syntax</span>
</li><li><span class="c">// these two strings are both empty, and are equivalent to each other</span>
</li></ol></div></div></div>
<p>Find out whether a <code class="docutils literal notranslate"><span class="pre">String</span></code> value is empty by checking its Boolean <code class="docutils literal notranslate"><span class="pre">isEmpty</span></code> property:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">emptyString</span>.<span class="nv">isEmpty</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;Nothing to see here&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;Nothing to see here&quot;</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID288">
<h2>String Mutability</h2>
<p>You indicate whether a particular <code class="docutils literal notranslate"><span class="pre">String</span></code> can be modified (or <em>mutated</em>) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">variableString</span> = <span class="s">&quot;Horse&quot;</span>
</li><li><span class="nv">variableString</span> += <span class="s">&quot; and carriage&quot;</span>
</li><li><span class="c">// variableString is now &quot;Horse and carriage&quot;</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">constantString</span> = <span class="s">&quot;Highlander&quot;</span>
</li><li><span class="nv">constantString</span> += <span class="s">&quot; and another Highlander&quot;</span>
</li><li><span class="c">// this reports a compile-time error - a constant string cannot be modified</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (<code class="docutils literal notranslate"><span class="pre">NSString</span></code> and <code class="docutils literal notranslate"><span class="pre">NSMutableString</span></code>) to indicate whether a string can be mutated.</p>
</div>
</div>
<div class="section" id="ID289">
<h2>Strings Are Value Types</h2>
<p>Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type is a <em>value type</em>. If you create a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value, that <code class="docutils literal notranslate"><span class="pre">String</span></code> value is <em>copied</em> when it’s passed to a function or method, or when it’s assigned to a constant or variable. In each case, a new copy of the existing <code class="docutils literal notranslate"><span class="pre">String</span></code> value is created, and the new copy is passed or assigned, not the original version. Value types are described in <a class="reference internal" href="ClassesAndStructures.xhtml#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a>.</p>
<p>Swift’s copy-by-default <code class="docutils literal notranslate"><span class="pre">String</span></code> behavior ensures that when a function or method passes you a <code class="docutils literal notranslate"><span class="pre">String</span></code> value, it’s clear that you own that exact <code class="docutils literal notranslate"><span class="pre">String</span></code> value, regardless of where it came from. You can be confident that the string you are passed won’t be modified unless you modify it yourself.</p>
<p>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.</p>
</div>
<div class="section" id="ID290">
<h2>Working with Characters</h2>
<p>You can access the individual <code class="docutils literal notranslate"><span class="pre">Character</span></code> values for a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over the string with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">character</span> <span class="k">in</span> <span class="s">&quot;Dog!🐶&quot;</span> {
</li><li>    <span class="nv">print</span>(<span class="nv">character</span>)
</li><li>}
</li><li><span class="c">// D</span>
</li><li><span class="c">// o</span>
</li><li><span class="c">// g</span>
</li><li><span class="c">// !</span>
</li><li><span class="c">// 🐶</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop is described in <a class="reference internal" href="ControlFlow.xhtml#ID121"><span class="std std-ref">For-In Loops</span></a>.</p>
<p>Alternatively, you can create a stand-alone <code class="docutils literal notranslate"><span class="pre">Character</span></code> constant or variable from a single-character string literal by providing a <code class="docutils literal notranslate"><span class="pre">Character</span></code> type annotation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">exclamationMark</span>: <span class="nc">Character</span> = <span class="s">&quot;!&quot;</span>
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">String</span></code> values can be constructed by passing an array of <code class="docutils literal notranslate"><span class="pre">Character</span></code> values as an argument to its initializer:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">catCharacters</span>: [<span class="nc">Character</span>] = [<span class="s">&quot;C&quot;</span>, <span class="s">&quot;a&quot;</span>, <span class="s">&quot;t&quot;</span>, <span class="s">&quot;!&quot;</span>, <span class="s">&quot;🐱&quot;</span>]
</li><li><span class="k">let</span> <span class="nv">catString</span> = <span class="nv">String</span>(<span class="nv">catCharacters</span>)
</li><li><span class="nv">print</span>(<span class="nv">catString</span>)
</li><li><span class="c">// Prints &quot;Cat!🐱&quot;</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID291">
<h2>Concatenating Strings and Characters</h2>
<p><code class="docutils literal notranslate"><span class="pre">String</span></code> values can be added together (or <em>concatenated</em>) with the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) to create a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">string1</span> = <span class="s">&quot;hello&quot;</span>
</li><li><span class="k">let</span> <span class="nv">string2</span> = <span class="s">&quot; there&quot;</span>
</li><li><span class="k">var</span> <span class="nv">welcome</span> = <span class="nv">string1</span> + <span class="nv">string2</span>
</li><li><span class="c">// welcome now equals &quot;hello there&quot;</span>
</li></ol></div></div></div>
<p>You can also append a <code class="docutils literal notranslate"><span class="pre">String</span></code> value to an existing <code class="docutils literal notranslate"><span class="pre">String</span></code> variable with the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">instruction</span> = <span class="s">&quot;look over&quot;</span>
</li><li><span class="nv">instruction</span> += <span class="nv">string2</span>
</li><li><span class="c">// instruction now equals &quot;look over there&quot;</span>
</li></ol></div></div></div>
<p>You can append a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value to a <code class="docutils literal notranslate"><span class="pre">String</span></code> variable with the <code class="docutils literal notranslate"><span class="pre">String</span></code> type’s <code class="docutils literal notranslate"><span class="pre">append()</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">exclamationMark</span>: <span class="nc">Character</span> = <span class="s">&quot;!&quot;</span>
</li><li><span class="nv">welcome</span>.<span class="nv">append</span>(<span class="nv">exclamationMark</span>)
</li><li><span class="c">// welcome now equals &quot;hello there!&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can’t append a <code class="docutils literal notranslate"><span class="pre">String</span></code> or <code class="docutils literal notranslate"><span class="pre">Character</span></code> to an existing <code class="docutils literal notranslate"><span class="pre">Character</span></code> variable, because a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value must contain a single character only.</p>
</div>
<p>If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">badStart</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">one</span>
</li><li><span class="s">two</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li><li><span class="k">let</span> <span class="nv">end</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">three</span>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li><li><span class="nv">print</span>(<span class="nv">badStart</span> + <span class="nv">end</span>)
</li><li><span class="c">// Prints two lines:</span>
</li><li><span class="c">// one</span>
</li><li><span class="c">// twothree</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">goodStart</span> = <span class="s">&quot;&quot;&quot;</span>
</li><li><span class="s">one</span>
</li><li><span class="s">two</span>
</li><li>
</li><li><span class="s">&quot;&quot;&quot;</span>
</li><li><span class="nv">print</span>(<span class="nv">goodStart</span> + <span class="nv">end</span>)
</li><li><span class="c">// Prints three lines:</span>
</li><li><span class="c">// one</span>
</li><li><span class="c">// two</span>
</li><li><span class="c">// three</span>
</li></ol></div></div></div>
<p>In the code above, concatenating <code class="docutils literal notranslate"><span class="pre">badStart</span></code> with <code class="docutils literal notranslate"><span class="pre">end</span></code> produces a two-line string, which isn’t the desired result. Because the last line of <code class="docutils literal notranslate"><span class="pre">badStart</span></code> doesn’t end with a line break, that line gets combined with the first line of <code class="docutils literal notranslate"><span class="pre">end</span></code>. In contrast, both lines of <code class="docutils literal notranslate"><span class="pre">goodStart</span></code> end with a line break, so when it’s combined with <code class="docutils literal notranslate"><span class="pre">end</span></code> the result has three lines, as expected.</p>
</div>
<div class="section" id="ID292">
<h2>String Interpolation</h2>
<p><em>String interpolation</em> is a way to construct a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. You can use string interpolation in both single-line and multiline string literals. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">multiplier</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">message</span> = <span class="s">&quot;</span>\<span class="p">(</span><span class="nv">multiplier</span><span class="p">)</span><span class="s"> times 2.5 is </span>\<span class="p">(</span><span class="nv">Double</span>(<span class="nv">multiplier</span>) * <span class="m">2.5</span><span class="p">)</span><span class="s">&quot;</span>
</li><li><span class="c">// message is &quot;3 times 2.5 is 7.5&quot;</span>
</li></ol></div></div></div>
<p>In the example above, the value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> is inserted into a string literal as <code class="docutils literal notranslate"><span class="pre">\(multiplier)</span></code>. This placeholder is replaced with the actual value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> when the string interpolation is evaluated to create an actual string.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> is also part of a larger expression later in the string. This expression calculates the value of <code class="docutils literal notranslate"><span class="pre">Double(multiplier)</span> <span class="pre">*</span> <span class="pre">2.5</span></code> and inserts the result (<code class="docutils literal notranslate"><span class="pre">7.5</span></code>) into the string. In this case, the expression is written as <code class="docutils literal notranslate"><span class="pre">\(Double(multiplier)</span> <span class="pre">*</span> <span class="pre">2.5)</span></code> when it’s included inside the string literal.</p>
<p>You can use extended string delimiters to create strings containing characters that would otherwise be treated as a string interpolation. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">#&quot;Write an interpolated string in Swift using \(multiplier).&quot;#</span>)
</li><li><span class="c">// Prints &quot;Write an interpolated string in Swift using \(multiplier).&quot;</span>
</li></ol></div></div></div>
<p>To use string interpolation inside a string that uses extended delimiters, match the number of number signs after the backslash to the number of number signs at the beginning and end of the string. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">#&quot;6 times 7 is </span>\#<span class="p">(</span><span class="m">6</span> * <span class="m">7</span><span class="p">)</span><span class="s">.&quot;#</span>)
</li><li><span class="c">// Prints &quot;6 times 7 is 42.&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>), a carriage return, or a line feed. However, they can contain other string literals.</p>
</div>
</div>
<div class="section" id="ID293">
<h2>Unicode</h2>
<p><em>Unicode</em> is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Character</span></code> types are fully Unicode-compliant, as described in this section.</p>
<div class="section" id="ID294">
<h3>Unicode Scalar Values</h3>
<p>Behind the scenes, Swift’s native <code class="docutils literal notranslate"><span class="pre">String</span></code> type is built from <em>Unicode scalar values</em>. A Unicode scalar value is a unique 21-bit number for a character or modifier, such as <code class="docutils literal notranslate"><span class="pre">U+0061</span></code> for <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>), or <code class="docutils literal notranslate"><span class="pre">U+1F425</span></code> for <code class="docutils literal notranslate"><span class="pre">FRONT-FACING</span> <span class="pre">BABY</span> <span class="pre">CHICK</span></code> (<code class="docutils literal notranslate"><span class="pre">&quot;🐥&quot;</span></code>).</p>
<p>Note that not all 21-bit Unicode scalar values are assigned to a character—some scalars are reserved for future assignment or for use in UTF-16 encoding. Scalar values that have been assigned to a character typically also have a name, such as <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">FRONT-FACING</span> <span class="pre">BABY</span> <span class="pre">CHICK</span></code> in the examples above.</p>
</div>
<div class="section" id="ID296">
<h3>Extended Grapheme Clusters</h3>
<p>Every instance of Swift’s <code class="docutils literal notranslate"><span class="pre">Character</span></code> type represents a single <em>extended grapheme cluster</em>. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</p>
<p>Here’s an example. The letter <code class="docutils literal notranslate"><span class="pre">é</span></code> can be represented as the single Unicode scalar <code class="docutils literal notranslate"><span class="pre">é</span></code> (<code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span> <span class="pre">WITH</span> <span class="pre">ACUTE</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+00E9</span></code>). However, the same letter can also be represented as a <em>pair</em> of scalars—a standard letter <code class="docutils literal notranslate"><span class="pre">e</span></code> (<code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+0065</span></code>), followed by the <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> scalar (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>). The <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> scalar is graphically applied to the scalar that precedes it, turning an <code class="docutils literal notranslate"><span class="pre">e</span></code> into an <code class="docutils literal notranslate"><span class="pre">é</span></code> when it’s rendered by a Unicode-aware text-rendering system.</p>
<p>In both cases, the letter <code class="docutils literal notranslate"><span class="pre">é</span></code> is represented as a single Swift <code class="docutils literal notranslate"><span class="pre">Character</span></code> value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">eAcute</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{E9}&quot;</span>                         <span class="c">// é</span>
</li><li><span class="k">let</span> <span class="nv">combinedEAcute</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{65}\u{301}&quot;</span>          <span class="c">// e followed by ́</span>
</li><li><span class="c">// eAcute is é, combinedEAcute is é</span>
</li></ol></div></div></div>
<p>Extended grapheme clusters are a flexible way to represent many complex script characters as a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value in Swift:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">precomposed</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{D55C}&quot;</span>                  <span class="c">// 한</span>
</li><li><span class="k">let</span> <span class="nv">decomposed</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{1112}\u{1161}\u{11AB}&quot;</span>   <span class="c">// ᄒ, ᅡ, ᆫ</span>
</li><li><span class="c">// precomposed is 한, decomposed is 한</span>
</li></ol></div></div></div>
<p>Extended grapheme clusters enable scalars for enclosing marks (such as <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ENCLOSING</span> <span class="pre">CIRCLE</span></code>, or <code class="docutils literal notranslate"><span class="pre">U+20DD</span></code>) to enclose other Unicode scalars as part of a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">enclosedEAcute</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{E9}\u{20DD}&quot;</span>
</li><li><span class="c">// enclosedEAcute is é⃝</span>
</li></ol></div></div></div>
<p>Unicode scalars for regional indicator symbols can be combined in pairs to make a single <code class="docutils literal notranslate"><span class="pre">Character</span></code> value, such as this combination of <code class="docutils literal notranslate"><span class="pre">REGIONAL</span> <span class="pre">INDICATOR</span> <span class="pre">SYMBOL</span> <span class="pre">LETTER</span> <span class="pre">U</span></code> (<code class="docutils literal notranslate"><span class="pre">U+1F1FA</span></code>) and <code class="docutils literal notranslate"><span class="pre">REGIONAL</span> <span class="pre">INDICATOR</span> <span class="pre">SYMBOL</span> <span class="pre">LETTER</span> <span class="pre">S</span></code> (<code class="docutils literal notranslate"><span class="pre">U+1F1F8</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">regionalIndicatorForUS</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{1F1FA}\u{1F1F8}&quot;</span>
</li><li><span class="c">// regionalIndicatorForUS is 🇺🇸</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID297">
<h2>Counting Characters</h2>
<p>To retrieve a count of the <code class="docutils literal notranslate"><span class="pre">Character</span></code> values in a string, use the <code class="docutils literal notranslate"><span class="pre">count</span></code> property of the string:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">unusualMenagerie</span> = <span class="s">&quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;unusualMenagerie has </span>\<span class="p">(</span><span class="nv">unusualMenagerie</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> characters&quot;</span>)
</li><li><span class="c">// Prints &quot;unusualMenagerie has 40 characters&quot;</span>
</li></ol></div></div></div>
<p>Note that Swift’s use of extended grapheme clusters for <code class="docutils literal notranslate"><span class="pre">Character</span></code> values means that string concatenation and modification may not always affect a string’s character count.</p>
<p>For example, if you initialize a new string with the four-character word <code class="docutils literal notranslate"><span class="pre">cafe</span></code>, and then append a <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>) to the end of the string, the resulting string will still have a character count of <code class="docutils literal notranslate"><span class="pre">4</span></code>, with a fourth character of <code class="docutils literal notranslate"><span class="pre">é</span></code>, not <code class="docutils literal notranslate"><span class="pre">e</span></code>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">word</span> = <span class="s">&quot;cafe&quot;</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;the number of characters in </span>\<span class="p">(</span><span class="nv">word</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">word</span>.<span class="nv">count</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;the number of characters in cafe is 4&quot;</span>
</li><li>
</li><li><span class="nv">word</span> += <span class="s">&quot;\u{301}&quot;</span>    <span class="c">// COMBINING ACUTE ACCENT, U+0301</span>
</li><li>
</li><li><span class="nv">print</span>(<span class="s">&quot;the number of characters in </span>\<span class="p">(</span><span class="nv">word</span><span class="p">)</span><span class="s"> is </span>\<span class="p">(</span><span class="nv">word</span>.<span class="nv">count</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;the number of characters in café is 4&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Extended grapheme clusters can be composed of multiple Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the <code class="docutils literal notranslate"><span class="pre">count</span></code> property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</p>
<p>The count of the characters returned by the <code class="docutils literal notranslate"><span class="pre">count</span></code> property isn’t always the same as the <code class="docutils literal notranslate"><span class="pre">length</span></code> property of an <code class="docutils literal notranslate"><span class="pre">NSString</span></code> that contains the same characters. The length of an <code class="docutils literal notranslate"><span class="pre">NSString</span></code> is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</p>
</div>
</div>
<div class="section" id="ID494">
<h2>Accessing and Modifying a String</h2>
<p>You access and modify a string through its methods and properties, or by using subscript syntax.</p>
<div class="section" id="ID534">
<h3>String Indices</h3>
<p>Each <code class="docutils literal notranslate"><span class="pre">String</span></code> value has an associated <em>index type</em>, <code class="docutils literal notranslate"><span class="pre">String.Index</span></code>, which corresponds to the position of each <code class="docutils literal notranslate"><span class="pre">Character</span></code> in the string.</p>
<p>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which <code class="docutils literal notranslate"><span class="pre">Character</span></code> is at a particular position, you must iterate over each Unicode scalar from the start or end of that <code class="docutils literal notranslate"><span class="pre">String</span></code>. For this reason, Swift strings can’t be indexed by integer values.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> property to access the position of the first <code class="docutils literal notranslate"><span class="pre">Character</span></code> of a <code class="docutils literal notranslate"><span class="pre">String</span></code>. The <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> property is the position after the last character in a <code class="docutils literal notranslate"><span class="pre">String</span></code>. As a result, the <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> property isn’t a valid argument to a string’s subscript. If a <code class="docutils literal notranslate"><span class="pre">String</span></code> is empty, <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> are equal.</p>
<p>You access the indices before and after a given index using the <code class="docutils literal notranslate"><span class="pre">index(before:)</span></code> and <code class="docutils literal notranslate"><span class="pre">index(after:)</span></code> methods of <code class="docutils literal notranslate"><span class="pre">String</span></code>. To access an index farther away from the given index, you can use the <code class="docutils literal notranslate"><span class="pre">index(_:offsetBy:)</span></code> method instead of calling one of these methods multiple times.</p>
<p>You can use subscript syntax to access the <code class="docutils literal notranslate"><span class="pre">Character</span></code> at a particular <code class="docutils literal notranslate"><span class="pre">String</span></code> index.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">greeting</span> = <span class="s">&quot;Guten Tag!&quot;</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">startIndex</span>]
</li><li><span class="c">// G</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">greeting</span>.<span class="nv">endIndex</span>)]
</li><li><span class="c">// !</span>
</li><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">after</span>: <span class="nv">greeting</span>.<span class="nv">startIndex</span>)]
</li><li><span class="c">// u</span>
</li><li><span class="k">let</span> <span class="nv">index</span> = <span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">greeting</span>.<span class="nv">startIndex</span>, <span class="nv">offsetBy</span>: <span class="m">7</span>)
</li><li><span class="nv">greeting</span>[<span class="nv">index</span>]
</li><li><span class="c">// a</span>
</li></ol></div></div></div>
<p>Attempting to access an index outside of a string’s range or a <code class="docutils literal notranslate"><span class="pre">Character</span></code> at an index outside of a string’s range will trigger a runtime error.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">greeting</span>[<span class="nv">greeting</span>.<span class="nv">endIndex</span>] <span class="c">// Error</span>
</li><li><span class="nv">greeting</span>.<span class="nv">index</span>(<span class="nv">after</span>: <span class="nv">greeting</span>.<span class="nv">endIndex</span>) <span class="c">// Error</span>
</li></ol></div></div></div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">indices</span></code> property to access all of the indices of individual characters in a string.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="nv">greeting</span>.<span class="nv">indices</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">greeting</span>[<span class="nv">index</span>]<span class="p">)</span><span class="s"> &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;G u t e n   T a g ! &quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">startIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">endIndex</span></code> properties and the <code class="docutils literal notranslate"><span class="pre">index(before:)</span></code>, <code class="docutils literal notranslate"><span class="pre">index(after:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">index(_:offsetBy:)</span></code> methods on any type that conforms to the <code class="docutils literal notranslate"><span class="pre">Collection</span></code> protocol. This includes <code class="docutils literal notranslate"><span class="pre">String</span></code>, as shown here, as well as collection types such as <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, and <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
</div>
</div>
<div class="section" id="ID496">
<h3>Inserting and Removing</h3>
<p>To insert a single character into a string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code> method, and to insert the contents of another string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">insert(contentsOf:at:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">welcome</span> = <span class="s">&quot;hello&quot;</span>
</li><li><span class="nv">welcome</span>.<span class="nv">insert</span>(<span class="s">&quot;!&quot;</span>, <span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>)
</li><li><span class="c">// welcome now equals &quot;hello!&quot;</span>
</li><li>
</li><li><span class="nv">welcome</span>.<span class="nv">insert</span>(<span class="nv">contentsOf</span>: <span class="s">&quot; there&quot;</span>, <span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>))
</li><li><span class="c">// welcome now equals &quot;hello there!&quot;</span>
</li></ol></div></div></div>
<p>To remove a single character from a string at a specified index, use the <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code> method, and to remove a substring at a specified range, use the <code class="docutils literal notranslate"><span class="pre">removeSubrange(_:)</span></code> method:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">welcome</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">before</span>: <span class="nv">welcome</span>.<span class="nv">endIndex</span>))
</li><li><span class="c">// welcome now equals &quot;hello there&quot;</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">range</span> = <span class="nv">welcome</span>.<span class="nv">index</span>(<span class="nv">welcome</span>.<span class="nv">endIndex</span>, <span class="nv">offsetBy</span>: <span class="m">-6</span>)..&lt;<span class="nv">welcome</span>.<span class="nv">endIndex</span>
</li><li><span class="nv">welcome</span>.<span class="nv">removeSubrange</span>(<span class="nv">range</span>)
</li><li><span class="c">// welcome now equals &quot;hello&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">insert(_:at:)</span></code>, <code class="docutils literal notranslate"><span class="pre">insert(contentsOf:at:)</span></code>, <code class="docutils literal notranslate"><span class="pre">remove(at:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">removeSubrange(_:)</span></code> methods on any type that conforms to the <code class="docutils literal notranslate"><span class="pre">RangeReplaceableCollection</span></code> protocol. This includes <code class="docutils literal notranslate"><span class="pre">String</span></code>, as shown here, as well as collection types such as <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, and <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="ID555">
<h2>Substrings</h2>
<p>When you get a substring from a string—for example, using a subscript or a method like <code class="docutils literal notranslate"><span class="pre">prefix(_:)</span></code>—the result is an instance of <a class="reference external" href="https://developer.apple.com/documentation/swift/substring"><code class="docutils literal notranslate"><span class="pre">Substring</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/substring]</span>, not another string. Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings. However, unlike strings, you use substrings for only a short amount of time while performing actions on a string. When you’re ready to store the result for a longer time, you convert the substring to an instance of <code class="docutils literal notranslate"><span class="pre">String</span></code>. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">greeting</span> = <span class="s">&quot;Hello, world!&quot;</span>
</li><li><span class="k">let</span> <span class="nv">index</span> = <span class="nv">greeting</span>.<span class="nv">firstIndex</span>(<span class="nv">of</span>: <span class="s">&quot;,&quot;</span>) ?? <span class="nv">greeting</span>.<span class="nv">endIndex</span>
</li><li><span class="k">let</span> <span class="nv">beginning</span> = <span class="nv">greeting</span>[..&lt;<span class="nv">index</span>]
</li><li><span class="c">// beginning is &quot;Hello&quot;</span>
</li><li>
</li><li><span class="c">// Convert the result to a String for long-term storage.</span>
</li><li><span class="k">let</span> <span class="nv">newString</span> = <span class="nv">String</span>(<span class="nv">beginning</span>)
</li></ol></div></div></div>
<p>Like strings, each substring has a region of memory where the characters that make up the substring are stored. The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring. (Strings have a similar optimization, but if two strings share memory, they’re equal.) This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring. As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used.</p>
<p>In the example above, <code class="docutils literal notranslate"><span class="pre">greeting</span></code> is a string, which means it has a region of memory where the characters that make up the string are stored. Because <code class="docutils literal notranslate"><span class="pre">beginning</span></code> is a substring of <code class="docutils literal notranslate"><span class="pre">greeting</span></code>, it reuses the memory that <code class="docutils literal notranslate"><span class="pre">greeting</span></code> uses. In contrast, <code class="docutils literal notranslate"><span class="pre">newString</span></code> is a string—when it’s created from the substring, it has its own storage. The figure below shows these relationships:</p>
<img alt="../_images/stringSubstring_2x.png" class="align-center" src="../_images/stringSubstring_2x.png" style="width: 382.0px;" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Substring</span></code> conform to the <a class="reference external" href="https://developer.apple.com/documentation/swift/stringprotocol"><code class="docutils literal notranslate"><span class="pre">StringProtocol</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/stringprotocol]</span> protocol, which means it’s often convenient for string-manipulation functions to accept a <code class="docutils literal notranslate"><span class="pre">StringProtocol</span></code> value. You can call such functions with either a <code class="docutils literal notranslate"><span class="pre">String</span></code> or <code class="docutils literal notranslate"><span class="pre">Substring</span></code> value.</p>
</div>
</div>
<div class="section" id="ID298">
<h2>Comparing Strings</h2>
<p>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</p>
<div class="section" id="ID299">
<h3>String and Character Equality</h3>
<p>String and character equality is checked with the “equal to” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and the “not equal to” operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>), as described in <a class="reference internal" href="BasicOperators.xhtml#ID70"><span class="std std-ref">Comparison Operators</span></a>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">quotation</span> = <span class="s">&quot;We&#39;re a lot alike, you and I.&quot;</span>
</li><li><span class="k">let</span> <span class="nv">sameQuotation</span> = <span class="s">&quot;We&#39;re a lot alike, you and I.&quot;</span>
</li><li><span class="k">if</span> <span class="nv">quotation</span> == <span class="nv">sameQuotation</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;These two strings are considered equal&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;These two strings are considered equal&quot;</span>
</li></ol></div></div></div>
<p>Two <code class="docutils literal notranslate"><span class="pre">String</span></code> values (or two <code class="docutils literal notranslate"><span class="pre">Character</span></code> values) are considered equal if their extended grapheme clusters are <em>canonically equivalent</em>. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span> <span class="pre">WITH</span> <span class="pre">ACUTE</span></code> (<code class="docutils literal notranslate"><span class="pre">U+00E9</span></code>) is canonically equivalent to <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">E</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0065</span></code>) followed by <code class="docutils literal notranslate"><span class="pre">COMBINING</span> <span class="pre">ACUTE</span> <span class="pre">ACCENT</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0301</span></code>). Both of these extended grapheme clusters are valid ways to represent the character <code class="docutils literal notranslate"><span class="pre">é</span></code>, and so they’re considered to be canonically equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E WITH ACUTE</span>
</li><li><span class="k">let</span> <span class="nv">eAcuteQuestion</span> = <span class="s">&quot;Voulez-vous un caf\u{E9}?&quot;</span>
</li><li>
</li><li><span class="c">// &quot;Voulez-vous un café?&quot; using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span>
</li><li><span class="k">let</span> <span class="nv">combinedEAcuteQuestion</span> = <span class="s">&quot;Voulez-vous un caf\u{65}\u{301}?&quot;</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">eAcuteQuestion</span> == <span class="nv">combinedEAcuteQuestion</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;These two strings are considered equal&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;These two strings are considered equal&quot;</span>
</li></ol></div></div></div>
<p>Conversely, <code class="docutils literal notranslate"><span class="pre">LATIN</span> <span class="pre">CAPITAL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0041</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code>), as used in English, is <em>not</em> equivalent to <code class="docutils literal notranslate"><span class="pre">CYRILLIC</span> <span class="pre">CAPITAL</span> <span class="pre">LETTER</span> <span class="pre">A</span></code> (<code class="docutils literal notranslate"><span class="pre">U+0410</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;А&quot;</span></code>), as used in Russian. The characters are visually similar, but don’t have the same linguistic meaning:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">latinCapitalLetterA</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{41}&quot;</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">cyrillicCapitalLetterA</span>: <span class="nc">Character</span> = <span class="s">&quot;\u{0410}&quot;</span>
</li><li>
</li><li><span class="k">if</span> <span class="nv">latinCapitalLetterA</span> != <span class="nv">cyrillicCapitalLetterA</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;These two characters aren&#39;t equivalent.&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;These two characters aren&#39;t equivalent.&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>String and character comparisons in Swift aren’t locale-sensitive.</p>
</div>
</div>
<div class="section" id="ID300">
<h3>Prefix and Suffix Equality</h3>
<p>To check whether a string has a particular string prefix or suffix, call the string’s <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> methods, both of which take a single argument of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and return a Boolean value.</p>
<p>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s <em>Romeo and Juliet</em>:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">romeoAndJuliet</span> = [
</li><li>    <span class="s">&quot;Act 1 Scene 1: Verona, A public place&quot;</span>,
</li><li>    <span class="s">&quot;Act 1 Scene 2: Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 1 Scene 3: A room in Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 1 Scene 4: A street outside Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 1 Scene 5: The Great Hall in Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 1: Outside Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 2: Capulet&#39;s orchard&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 3: Outside Friar Lawrence&#39;s cell&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 4: A street in Verona&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 5: Capulet&#39;s mansion&quot;</span>,
</li><li>    <span class="s">&quot;Act 2 Scene 6: Friar Lawrence&#39;s cell&quot;</span>
</li><li>]
</li></ol></div></div></div>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> method with the <code class="docutils literal notranslate"><span class="pre">romeoAndJuliet</span></code> array to count the number of scenes in Act 1 of the play:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">act1SceneCount</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">scene</span> <span class="k">in</span> <span class="nv">romeoAndJuliet</span> {
</li><li>    <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasPrefix</span>(<span class="s">&quot;Act 1 &quot;</span>) {
</li><li>        <span class="nv">act1SceneCount</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">&quot;There are </span>\<span class="p">(</span><span class="nv">act1SceneCount</span><span class="p">)</span><span class="s"> scenes in Act 1&quot;</span>)
</li><li><span class="c">// Prints &quot;There are 5 scenes in Act 1&quot;</span>
</li></ol></div></div></div>
<p>Similarly, use the <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">mansionCount</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">cellCount</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">scene</span> <span class="k">in</span> <span class="nv">romeoAndJuliet</span> {
</li><li>    <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasSuffix</span>(<span class="s">&quot;Capulet&#39;s mansion&quot;</span>) {
</li><li>        <span class="nv">mansionCount</span> += <span class="m">1</span>
</li><li>    } <span class="k">else</span> <span class="k">if</span> <span class="nv">scene</span>.<span class="nv">hasSuffix</span>(<span class="s">&quot;Friar Lawrence&#39;s cell&quot;</span>) {
</li><li>        <span class="nv">cellCount</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">mansionCount</span><span class="p">)</span><span class="s"> mansion scenes; </span>\<span class="p">(</span><span class="nv">cellCount</span><span class="p">)</span><span class="s"> cell scenes&quot;</span>)
</li><li><span class="c">// Prints &quot;6 mansion scenes; 2 cell scenes&quot;</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hasPrefix(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">hasSuffix(_:)</span></code> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in <a class="reference internal" href="#ID299"><span class="std std-ref">String and Character Equality</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="ID301">
<h2>Unicode Representations of Strings</h2>
<p>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined <em>encoding forms</em>. Each form encodes the string in small chunks known as <em>code units</em>. These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</p>
<p>Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> statement, to access its individual <code class="docutils literal notranslate"><span class="pre">Character</span></code> values as Unicode extended grapheme clusters. This process is described in <a class="reference internal" href="#ID290"><span class="std std-ref">Working with Characters</span></a>.</p>
<p>Alternatively, access a <code class="docutils literal notranslate"><span class="pre">String</span></code> value in one of three other Unicode-compliant representations:</p>
<ul class="simple">
<li><p>A collection of UTF-8 code units (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">utf8</span></code> property)</p></li>
<li><p>A collection of UTF-16 code units (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">utf16</span></code> property)</p></li>
<li><p>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s <code class="docutils literal notranslate"><span class="pre">unicodeScalars</span></code> property)</p></li>
</ul>
<p>Each example below shows a different representation of the following string, which is made up of the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">‼</span></code> (<code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code>, or Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code>), and the 🐶 character (<code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code>, or Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+1F436</span></code>):</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">dogString</span> = <span class="s">&quot;Dog‼🐶&quot;</span>
</li></ol></div></div></div>
<div class="section" id="ID302">
<h3>UTF-8 Representation</h3>
<p>You can access a UTF-8 representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over its <code class="docutils literal notranslate"><span class="pre">utf8</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">String.UTF8View</span></code>, which is a collection of unsigned 8-bit (<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>) values, one for each byte in the string’s UTF-8 representation:</p>
<img alt="../_images/UTF8_2x.png" class="align-center" src="../_images/UTF8_2x.png" style="width: 681.0px;" />
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">codeUnit</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">utf8</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">codeUnit</span><span class="p">)</span><span class="s"> &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">&quot;&quot;</span>)
</li><li><span class="c">// Prints &quot;68 111 103 226 128 188 240 159 144 182 &quot;</span>
</li></ol></div></div></div>
<p>In the example above, the first three decimal <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>, whose UTF-8 representation is the same as their ASCII representation. The next three decimal <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">226</span></code>, <code class="docutils literal notranslate"><span class="pre">128</span></code>, <code class="docutils literal notranslate"><span class="pre">188</span></code>) are a three-byte UTF-8 representation of the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character. The last four <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">240</span></code>, <code class="docutils literal notranslate"><span class="pre">159</span></code>, <code class="docutils literal notranslate"><span class="pre">144</span></code>, <code class="docutils literal notranslate"><span class="pre">182</span></code>) are a four-byte UTF-8 representation of the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character.</p>
</div>
<div class="section" id="ID303">
<h3>UTF-16 Representation</h3>
<p>You can access a UTF-16 representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> by iterating over its <code class="docutils literal notranslate"><span class="pre">utf16</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">String.UTF16View</span></code>, which is a collection of unsigned 16-bit (<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>) values, one for each 16-bit code unit in the string’s UTF-16 representation:</p>
<img alt="../_images/UTF16_2x.png" class="align-center" src="../_images/UTF16_2x.png" style="width: 548.0px;" />
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">codeUnit</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">utf16</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">codeUnit</span><span class="p">)</span><span class="s"> &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">&quot;&quot;</span>)
</li><li><span class="c">// Prints &quot;68 111 103 8252 55357 56374 &quot;</span>
</li></ol></div></div></div>
<p>Again, the first three <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</p>
<p>The fourth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> value (<code class="docutils literal notranslate"><span class="pre">8252</span></code>) is a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">203C</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character. This character can be represented as a single code unit in UTF-16.</p>
<p>The fifth and sixth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> values (<code class="docutils literal notranslate"><span class="pre">55357</span></code> and <code class="docutils literal notranslate"><span class="pre">56374</span></code>) are a UTF-16 surrogate pair representation of the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character. These values are a high-surrogate value of <code class="docutils literal notranslate"><span class="pre">U+D83D</span></code> (decimal value <code class="docutils literal notranslate"><span class="pre">55357</span></code>) and a low-surrogate value of <code class="docutils literal notranslate"><span class="pre">U+DC36</span></code> (decimal value <code class="docutils literal notranslate"><span class="pre">56374</span></code>).</p>
</div>
<div class="section" id="ID304">
<h3>Unicode Scalar Representation</h3>
<p>You can access a Unicode scalar representation of a <code class="docutils literal notranslate"><span class="pre">String</span></code> value by iterating over its <code class="docutils literal notranslate"><span class="pre">unicodeScalars</span></code> property. This property is of type <code class="docutils literal notranslate"><span class="pre">UnicodeScalarView</span></code>, which is a collection of values of type <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> has a <code class="docutils literal notranslate"><span class="pre">value</span></code> property that returns the scalar’s 21-bit value, represented within a <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> value:</p>
<img alt="../_images/UnicodeScalar_2x.png" class="align-center" src="../_images/UnicodeScalar_2x.png" style="width: 470.0px;" />
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">scalar</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">unicodeScalars</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">scalar</span>.<span class="nv">value</span><span class="p">)</span><span class="s"> &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>}
</li><li><span class="nv">print</span>(<span class="s">&quot;&quot;</span>)
</li><li><span class="c">// Prints &quot;68 111 103 8252 128054 &quot;</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> properties for the first three <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> values (<code class="docutils literal notranslate"><span class="pre">68</span></code>, <code class="docutils literal notranslate"><span class="pre">111</span></code>, <code class="docutils literal notranslate"><span class="pre">103</span></code>) once again represent the characters <code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>The fourth <code class="docutils literal notranslate"><span class="pre">codeUnit</span></code> value (<code class="docutils literal notranslate"><span class="pre">8252</span></code>) is again a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">203C</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+203C</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">EXCLAMATION</span> <span class="pre">MARK</span></code> character.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> property of the fifth and final <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code>, <code class="docutils literal notranslate"><span class="pre">128054</span></code>, is a decimal equivalent of the hexadecimal value <code class="docutils literal notranslate"><span class="pre">1F436</span></code>, which represents the Unicode scalar <code class="docutils literal notranslate"><span class="pre">U+1F436</span></code> for the <code class="docutils literal notranslate"><span class="pre">DOG</span> <span class="pre">FACE</span></code> character.</p>
<p>As an alternative to querying their <code class="docutils literal notranslate"><span class="pre">value</span></code> properties, each <code class="docutils literal notranslate"><span class="pre">UnicodeScalar</span></code> value can also be used to construct a new <code class="docutils literal notranslate"><span class="pre">String</span></code> value, such as with string interpolation:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">scalar</span> <span class="k">in</span> <span class="nv">dogString</span>.<span class="nv">unicodeScalars</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="nv">scalar</span><span class="p">)</span><span class="s"> &quot;</span>)
</li><li>}
</li><li><span class="c">// D</span>
</li><li><span class="c">// o</span>
</li><li><span class="c">// g</span>
</li><li><span class="c">// ‼</span>
</li><li><span class="c">// 🐶</span>
</li></ol></div></div></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>