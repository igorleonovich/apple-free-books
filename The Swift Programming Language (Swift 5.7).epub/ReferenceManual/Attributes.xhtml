<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Attributes</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="attributes">
<h1>Attributes</h1>
<p>There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types. An attribute provides additional information about the declaration or type. For example, the <code class="docutils literal notranslate"><span class="pre">discardableResult</span></code> attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.</p>
<p>You specify an attribute by writing the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> symbol followed by the attribute’s name and any arguments that the attribute accepts:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="gi">attribute name</span>
</li><li>@<span class="gi">attribute name</span>(<span class="gi">attribute arguments</span>)
</li></ol></div></div></div>
<p>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration. These <em>attribute arguments</em> are enclosed in parentheses, and their format is defined by the attribute they belong to.</p>
<div class="section" id="ID348">
<h2>Declaration Attributes</h2>
<p>You can apply a declaration attribute to declarations only.</p>
<div class="section" id="ID583">
<h3>available</h3>
<p>Apply this attribute to indicate a declaration’s life cycle relative to certain Swift language versions or certain platforms and operating system versions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute always appears with a list of two or more comma-separated attribute arguments. These arguments begin with one of the following platform or language names:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iOS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iOSApplicationExtension</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macOS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macOSApplicationExtension</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macCatalyst</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macCatalystApplicationExtension</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">watchOS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">watchOSApplicationExtension</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tvOS</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tvOSApplicationExtension</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">swift</span></code></p></li>
</ul>
<p>You can also use an asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) to indicate the availability of the declaration on all of the platform names listed above. An <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute that specifies availability using a Swift version number can’t use the asterisk.</p>
<p>The remaining arguments can appear in any order and specify additional information about the declaration’s life cycle, including important milestones.</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> argument indicates that the declaration isn’t available on the specified platform. This argument can’t be used when specifying Swift version availability.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">introduced</span></code> argument indicates the first version of the specified platform or language in which the declaration was introduced. It has the following form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">introduced</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p>The <em>version number</em> consists of one to three positive integers, separated by periods.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> argument indicates the first version of the specified platform or language in which the declaration was deprecated. It has the following form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">deprecated</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p>The optional <em>version number</em> consists of one to three positive integers, separated by periods. Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred. If you omit the version number, omit the colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>) as well.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">obsoleted</span></code> argument indicates the first version of the specified platform or language in which the declaration was obsoleted. When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used. It has the following form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">obsoleted</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p>The <em>version number</em> consists of one to three positive integers, separated by periods.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">message</span></code> argument provides a textual message that the compiler displays when emitting a warning or error about the use of a deprecated or obsoleted declaration. It has the following form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">message</span>: <span class="gi">message</span>
</li></ol></div></div></div>
<p>The <em>message</em> consists of a string literal.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">renamed</span></code> argument provides a textual message that indicates the new name for a declaration that’s been renamed. The compiler displays the new name when emitting an error about the use of a renamed declaration. It has the following form:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">renamed</span>: <span class="gi">new name</span>
</li></ol></div></div></div>
<p>The <em>new name</em> consists of a string literal.</p>
<p>You can apply the <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute with the <code class="docutils literal notranslate"><span class="pre">renamed</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> arguments to a type alias declaration, as shown below, to indicate that the name of a declaration changed between releases of a framework or library. This combination results in a compile-time error that the declaration has been renamed.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// First release</span>
</li><li><span class="k">protocol</span> <span class="nv">MyProtocol</span> {
</li><li>    <span class="c">// protocol definition</span>
</li><li>}
</li></ol></div></div></div>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// Subsequent release renames MyProtocol</span>
</li><li><span class="k">protocol</span> <span class="nv">MyRenamedProtocol</span> {
</li><li>    <span class="c">// protocol definition</span>
</li><li>}
</li><li>
</li><li><span class="k">@available</span>(*, <span class="nv">unavailable</span>, <span class="nv">renamed</span>: <span class="s">&quot;MyRenamedProtocol&quot;</span>)
</li><li><span class="k">typealias</span> <span class="nv">MyProtocol</span> = <span class="nc">MyRenamedProtocol</span>
</li></ol></div></div></div>
</li>
</ul>
<p>You can apply multiple <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes on a single declaration to specify the declaration’s availability on different platforms and different versions of Swift. The declaration that the <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute applies to is ignored if the attribute specifies a platform or language version that doesn’t match the current target. If you use multiple <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes, the effective availability is the combination of the platform and Swift availabilities.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute only specifies an <code class="docutils literal notranslate"><span class="pre">introduced</span></code> argument in addition to a platform or language name argument, you can use the following shorthand syntax instead:</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@available</span>(<span class="gi">platform name</span> <span class="gi">version number</span>, *)
</li><li><span class="k">@available</span>(<span class="nv">swift</span> <span class="gi">version number</span>)
</li></ol></div></div></div>
<p>The shorthand syntax for <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes concisely expresses availability for multiple platforms. Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@available</span>(<span class="k">iOS</span> <span class="m">10.0</span>, <span class="k">macOS</span> <span class="m">10.12</span>, *)
</li><li><span class="k">class</span> <span class="nv">MyClass</span> {
</li><li>    <span class="c">// class definition</span>
</li><li>}
</li></ol></div></div></div>
<p>An <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute that specifies availability using a Swift version number can’t additionally specify a declaration’s platform availability. Instead, use separate <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes to specify a Swift version availability and one or more platform availabilities.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@available</span>(<span class="nv">swift</span> <span class="m">3.0</span>.<span class="m">2</span>)
</li><li><span class="k">@available</span>(<span class="k">macOS</span> <span class="m">10.12</span>, *)
</li><li><span class="k">struct</span> <span class="nv">MyStruct</span> {
</li><li>    <span class="c">// struct definition</span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID584">
<h3>discardableResult</h3>
<p>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</p>
</div>
<div class="section" id="ID603">
<h3>dynamicCallable</h3>
<p>Apply this attribute to a class, structure, enumeration, or protocol to treat instances of the type as callable functions. The type must implement either a <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> method, a <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method, or both.</p>
<p>You can call an instance of a dynamically callable type as if it’s a function that takes any number of arguments.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@dynamicCallable</span>
</li><li><span class="k">struct</span> <span class="nv">TelephoneExchange</span> {
</li><li>    <span class="k">func</span> <span class="nv">dynamicallyCall</span>(<span class="nv">withArguments</span> <span class="nv">phoneNumber</span>: [<span class="nc">Int</span>]) {
</li><li>        <span class="k">if</span> <span class="nv">phoneNumber</span> == [<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>] {
</li><li>            <span class="nv">print</span>(<span class="s">&quot;Get Swift help on forums.swift.org&quot;</span>)
</li><li>        } <span class="k">else</span> {
</li><li>            <span class="nv">print</span>(<span class="s">&quot;Unrecognized number&quot;</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">dial</span> = <span class="nv">TelephoneExchange</span>()
</li><li>
</li><li><span class="c">// Use a dynamic method call.</span>
</li><li><span class="nv">dial</span>(<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>)
</li><li><span class="c">// Prints &quot;Get Swift help on forums.swift.org&quot;</span>
</li><li>
</li><li><span class="nv">dial</span>(<span class="m">8</span>, <span class="m">6</span>, <span class="m">7</span>, <span class="m">5</span>, <span class="m">3</span>, <span class="m">0</span>, <span class="m">9</span>)
</li><li><span class="c">// Prints &quot;Unrecognized number&quot;</span>
</li><li>
</li><li><span class="c">// Call the underlying method directly.</span>
</li><li><span class="nv">dial</span>.<span class="nv">dynamicallyCall</span>(<span class="nv">withArguments</span>: [<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>])
</li></ol></div></div></div>
<p>The declaration of the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> method must have a single parameter that conforms to the <a class="reference external" href="https://developer.apple.com/documentation/swift/expressiblebyarrayliteral"><code class="docutils literal notranslate"><span class="pre">ExpressibleByArrayLiteral</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/expressiblebyarrayliteral]</span> protocol—like <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> in the example above. The return type can be any type.</p>
<p>You can include labels in a dynamic method call if you implement the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@dynamicCallable</span>
</li><li><span class="k">struct</span> <span class="nv">Repeater</span> {
</li><li>    <span class="k">func</span> <span class="nv">dynamicallyCall</span>(<span class="nv">withKeywordArguments</span> <span class="nv">pairs</span>: <span class="nc">KeyValuePairs</span>&lt;<span class="nc">String</span>, <span class="nc">Int</span>&gt;) -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="nv">pairs</span>
</li><li>            .<span class="nv">map</span> { <span class="nv">label</span>, <span class="nv">count</span> <span class="k">in</span>
</li><li>                <span class="nv">repeatElement</span>(<span class="nv">label</span>, <span class="nv">count</span>: <span class="nv">count</span>).<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">&quot; &quot;</span>)
</li><li>            }
</li><li>            .<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">&quot;\n&quot;</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">repeatLabels</span> = <span class="nv">Repeater</span>()
</li><li><span class="nv">print</span>(<span class="nv">repeatLabels</span>(<span class="nv">a</span>: <span class="m">1</span>, <span class="nv">b</span>: <span class="m">2</span>, <span class="nv">c</span>: <span class="m">3</span>, <span class="nv">b</span>: <span class="m">2</span>, <span class="nv">a</span>: <span class="m">1</span>))
</li><li><span class="c">// a</span>
</li><li><span class="c">// b b</span>
</li><li><span class="c">// c c c</span>
</li><li><span class="c">// b b</span>
</li><li><span class="c">// a</span>
</li></ol></div></div></div>
<p>The declaration of the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method must have a single parameter that conforms to the <a class="reference external" href="https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral"><code class="docutils literal notranslate"><span class="pre">ExpressibleByDictionaryLiteral</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral]</span> protocol, and the return type can be any type. The parameter’s <a class="reference external" href="https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key"><code class="docutils literal notranslate"><span class="pre">Key</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key]</span> must be <a class="reference external" href="https://developer.apple.com/documentation/swift/expressiblebystringliteral"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/expressiblebystringliteral]</span>. The previous example uses <a class="reference external" href="https://developer.apple.com/documentation/swift/keyvaluepairs"><code class="docutils literal notranslate"><span class="pre">KeyValuePairs</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/keyvaluepairs]</span> as the parameter type so that callers can include duplicate parameter labels—<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> appear multiple times in the call to <code class="docutils literal notranslate"><span class="pre">repeat</span></code>.</p>
<p>If you implement both <code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code> methods, <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> is called when the method call includes keyword arguments. In all other cases, <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> is called.</p>
<p>You can only call a dynamically callable instance with arguments and a return value that match the types you specify in one of your <code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code> method implementations. The call in the following example doesn’t compile because there isn’t an implementation of <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> that takes <code class="docutils literal notranslate"><span class="pre">KeyValuePairs&lt;String,</span> <span class="pre">String&gt;</span></code>.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">repeatLabels</span>(<span class="nv">a</span>: <span class="s">&quot;four&quot;</span>) <span class="c">// Error</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID585">
<h3>dynamicMemberLookup</h3>
<p>Apply this attribute to a class, structure, enumeration, or protocol to enable members to be looked up by name at runtime. The type must implement a <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> subscript.</p>
<p>In an explicit member expression, if there isn’t a corresponding declaration for the named member, the expression is understood as a call to the type’s <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> subscript, passing information about the member as the argument. The subscript can accept a parameter that’s either a key path or a member name; if you implement both subscripts, the subscript that takes key path argument is used.</p>
<p>An implementation of <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> can accept key paths using an argument of type <a class="reference external" href="https://developer.apple.com/documentation/swift/keypath"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/keypath]</span>, <a class="reference external" href="https://developer.apple.com/documentation/swift/writablekeypath"><code class="docutils literal notranslate"><span class="pre">WritableKeyPath</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/writablekeypath]</span>, or <a class="reference external" href="https://developer.apple.com/documentation/swift/referencewritablekeypath"><code class="docutils literal notranslate"><span class="pre">ReferenceWritableKeyPath</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/referencewritablekeypath]</span>. It can accept member names using an argument of a type that conforms to the <a class="reference external" href="https://developer.apple.com/documentation/swift/expressiblebystringliteral"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/expressiblebystringliteral]</span> protocol—in most cases, <code class="docutils literal notranslate"><span class="pre">String</span></code>. The subscript’s return type can be any type.</p>
<p>Dynamic member lookup by member name can be used to create a wrapper type around data that can’t be type checked at compile time, such as when bridging data from other languages into Swift. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@dynamicMemberLookup</span>
</li><li><span class="k">struct</span> <span class="nv">DynamicStruct</span> {
</li><li>    <span class="k">let</span> <span class="nv">dictionary</span> = [<span class="s">&quot;someDynamicMember&quot;</span>: <span class="m">325</span>,
</li><li>                      <span class="s">&quot;someOtherMember&quot;</span>: <span class="m">787</span>]
</li><li>    <span class="k">subscript</span>(<span class="nv">dynamicMember</span> <span class="nv">member</span>: <span class="nc">String</span>) -&gt; <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="nv">dictionary</span>[<span class="nv">member</span>] ?? <span class="m">1054</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">s</span> = <span class="nv">DynamicStruct</span>()
</li><li>
</li><li><span class="c">// Use dynamic member lookup.</span>
</li><li><span class="k">let</span> <span class="nv">dynamic</span> = <span class="nv">s</span>.<span class="nv">someDynamicMember</span>
</li><li><span class="nv">print</span>(<span class="nv">dynamic</span>)
</li><li><span class="c">// Prints &quot;325&quot;</span>
</li><li>
</li><li><span class="c">// Call the underlying subscript directly.</span>
</li><li><span class="k">let</span> <span class="nv">equivalent</span> = <span class="nv">s</span>[<span class="nv">dynamicMember</span>: <span class="s">&quot;someDynamicMember&quot;</span>]
</li><li><span class="nv">print</span>(<span class="nv">dynamic</span> == <span class="nv">equivalent</span>)
</li><li><span class="c">// Prints &quot;true&quot;</span>
</li></ol></div></div></div>
<p>Dynamic member lookup by key path can be used to implement a wrapper type in a way that supports compile-time type checking. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> { <span class="k">var</span> <span class="nv">x</span>, <span class="nv">y</span>: <span class="nc">Int</span> }
</li><li>
</li><li><span class="k">@dynamicMemberLookup</span>
</li><li><span class="k">struct</span> <span class="nv">PassthroughWrapper</span>&lt;<span class="nv">Value</span>&gt; {
</li><li>    <span class="k">var</span> <span class="nv">value</span>: <span class="nc">Value</span>
</li><li>    <span class="k">subscript</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">dynamicMember</span> <span class="nv">member</span>: <span class="nc">KeyPath</span>&lt;<span class="nc">Value</span>, <span class="nc">T</span>&gt;) -&gt; <span class="nc">T</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">value</span>[<span class="nv">keyPath</span>: <span class="nv">member</span>] }
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">point</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">381</span>, <span class="nv">y</span>: <span class="m">431</span>)
</li><li><span class="k">let</span> <span class="nv">wrapper</span> = <span class="nv">PassthroughWrapper</span>(<span class="nv">value</span>: <span class="nv">point</span>)
</li><li><span class="nv">print</span>(<span class="nv">wrapper</span>.<span class="nv">x</span>)
</li></ol></div></div></div>
</div>
<div class="section" id="ID620">
<h3>frozen</h3>
<p>Apply this attribute to a structure or enumeration declaration to restrict the kinds of changes you can make to the type. This attribute is allowed only when compiling in library evolution mode. Future versions of the library can’t change the declaration by adding, removing, or reordering an enumeration’s cases or a structure’s stored instance properties. These changes are allowed on nonfrozen types, but they break ABI compatibility for frozen types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the compiler isn’t in library evolution mode, all structures and enumerations are implicitly frozen, and this attribute is ignored.</p>
</div>
<p>In library evolution mode, code that interacts with members of nonfrozen structures and enumerations is compiled in a way that allows it to continue working without recompiling even if a future version of the library adds, removes, or reorders some of that type’s members. The compiler makes this possible using techniques like looking up information at runtime and adding a layer of indirection. Marking a structure or enumeration as frozen gives up this flexibility to gain performance: Future versions of the library can make only limited changes to the type, but the compiler can make additional optimizations in code that interacts with the type’s members.</p>
<p>Frozen types, the types of the stored properties of frozen structures, and the associated values of frozen enumeration cases must be public or marked with the <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> attribute. The properties of a frozen structure can’t have property observers, and expressions that provide the initial value for stored instance properties must follow the same restrictions as inlinable functions, as discussed in <a class="reference internal" href="#ID587"><span class="std std-ref">inlinable</span></a>.</p>
<p>To enable library evolution mode on the command line, pass the <code class="docutils literal notranslate"><span class="pre">-enable-library-evolution</span></code> option to the Swift compiler. To enable it in Xcode, set the “Build Libraries for Distribution” build setting (<code class="docutils literal notranslate"><span class="pre">BUILD_LIBRARY_FOR_DISTRIBUTION</span></code>) to Yes, as described in <a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev04b3a04ba">Xcode Help</a><span class="link-target"> [https://help.apple.com/xcode/mac/current/#/dev04b3a04ba]</span>.</p>
<p>A switch statement over a frozen enumeration doesn’t require a <code class="docutils literal notranslate"><span class="pre">default</span></code> case, as discussed in <a class="reference internal" href="Statements.xhtml#ID602"><span class="std std-ref">Switching Over Future Enumeration Cases</span></a>. Including a <code class="docutils literal notranslate"><span class="pre">default</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;unknown</span> <span class="pre">default</span></code> case when switching over a frozen enumeration produces a warning because that code is never executed.</p>
</div>
<div class="section" id="ID586">
<h3>GKInspectable</h3>
<p>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI. Applying this attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
</div>
<div class="section" id="ID587">
<h3>inlinable</h3>
<p>Apply this attribute to a function, method, computed property, subscript, convenience initializer, or deinitializer declaration to expose that declaration’s implementation as part of the module’s public interface. The compiler is allowed to replace calls to an inlinable symbol with a copy of the symbol’s implementation at the call site.</p>
<p>Inlinable code can interact with <code class="docutils literal notranslate"><span class="pre">public</span></code> symbols declared in any module, and it can interact with <code class="docutils literal notranslate"><span class="pre">internal</span></code> symbols declared in the same module that are marked with the <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> attribute. Inlinable code can’t interact with <code class="docutils literal notranslate"><span class="pre">private</span></code> or <code class="docutils literal notranslate"><span class="pre">fileprivate</span></code> symbols.</p>
<p>This attribute can’t be applied to declarations that are nested inside functions or to <code class="docutils literal notranslate"><span class="pre">fileprivate</span></code> or <code class="docutils literal notranslate"><span class="pre">private</span></code> declarations. Functions and closures that are defined inside an inlinable function are implicitly inlinable, even though they can’t be marked with this attribute.</p>
</div>
<div class="section" id="ID626">
<h3>main</h3>
<p>Apply this attribute to a structure, class, or enumeration declaration to indicate that it contains the top-level entry point for program flow. The type must provide a <code class="docutils literal notranslate"><span class="pre">main</span></code> type function that doesn’t take any arguments and returns <code class="docutils literal notranslate"><span class="pre">Void</span></code>. For example:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">main</span>
</li><li><span class="k">struct</span> <span class="nv">MyTopLevel</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">main</span>() {
</li><li>        <span class="c">// Top-level code goes here</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Another way to describe the requirements of the <code class="docutils literal notranslate"><span class="pre">main</span></code> attribute is that the type you write this attribute on must satisfy the same requirements as types that conform to the following hypothetical protocol:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">ProvidesMain</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">main</span>() <span class="k">throws</span>
</li><li>}
</li></ol></div></div></div>
<p>The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.xhtml#ID352"><span class="std std-ref">Top-Level Code</span></a>.</p>
</div>
<div class="section" id="ID588">
<h3>nonobjc</h3>
<p>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. The <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</p>
<p>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
<p>You use the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute to resolve circularity for bridging methods in a class marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute, and to allow overloading of methods and initializers in a class marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
<p>A method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute can’t override a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. However, a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can override a method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute. Similarly, a method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute can’t satisfy a protocol requirement for a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
</div>
<div class="section" id="ID589">
<h3>NSApplicationMain</h3>
<p>Apply this attribute to a class to indicate that it’s the application delegate. Using this attribute is equivalent to calling the <code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code> function.</p>
<p>If you don’t use this attribute, supply a <code class="docutils literal notranslate"><span class="pre">main.swift</span></code> file with code at the top level that calls the <code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code> function as follows:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">import</span> <span class="nv">AppKit</span>
</li><li><span class="nv">NSApplicationMain</span>(<span class="nv">CommandLine</span>.<span class="nv">argc</span>, <span class="nv">CommandLine</span>.<span class="nv">unsafeArgv</span>)
</li></ol></div></div></div>
<p>The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.xhtml#ID352"><span class="std std-ref">Top-Level Code</span></a>.</p>
</div>
<div class="section" id="ID590">
<h3>NSCopying</h3>
<p>Apply this attribute to a stored variable property of a class. This attribute causes the property’s setter to be synthesized with a <em>copy</em> of the property’s value—returned by the <code class="docutils literal notranslate"><span class="pre">copyWithZone(_:)</span></code> method—instead of the value of the property itself. The type of the property must conform to the <code class="docutils literal notranslate"><span class="pre">NSCopying</span></code> protocol.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NSCopying</span></code> attribute behaves in a way similar to the Objective-C <code class="docutils literal notranslate"><span class="pre">copy</span></code> property attribute.</p>
</div>
<div class="section" id="ID591">
<h3>NSManaged</h3>
<p>Apply this attribute to an instance method or stored variable property of a class that inherits from <code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code> to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description. For a property marked with the <code class="docutils literal notranslate"><span class="pre">NSManaged</span></code> attribute, Core Data also provides the storage at runtime. Applying this attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
</div>
<div class="section" id="ID592">
<h3>objc</h3>
<p>Apply this attribute to any declaration that can be represented in Objective-C—for example, nonnested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes, protocols and optional members of a protocol, initializers, and subscripts. The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute tells the compiler that a declaration is available to use in Objective-C code.</p>
<p>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute.</p>
<p>The compiler implicitly adds the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to subclasses of any class defined in Objective-C. However, the subclass must not be generic, and must not inherit from any generic classes. You can explicitly add the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to a subclass that meets these criteria, to specify its Objective-C name as discussed below. Protocols that are marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can’t inherit from protocols that aren’t marked with this attribute.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute is also implicitly added in the following cases:</p>
<ul class="simple">
<li><p>The declaration is an override in a subclass, and the superclass’s declaration has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p></li>
<li><p>The declaration satisfies a requirement from a protocol that has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p></li>
<li><p>The declaration has the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>, <code class="docutils literal notranslate"><span class="pre">NSManaged</span></code>, or <code class="docutils literal notranslate"><span class="pre">GKInspectable</span></code> attribute.</p></li>
</ul>
<p>If you apply the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name. The first letter of the case name is capitalized. For example, a case named <code class="docutils literal notranslate"><span class="pre">venus</span></code> in a Swift <code class="docutils literal notranslate"><span class="pre">Planet</span></code> enumeration is exposed to Objective-C code as a case named <code class="docutils literal notranslate"><span class="pre">PlanetVenus</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute optionally accepts a single attribute argument, which consists of an identifier. The identifier specifies the name to be exposed to Objective-C for the entity that the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute applies to. You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers. If you specify the Objective-C name for a class, protocol, or enumeration, include a three-letter prefix on the name, as described in <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1">Conventions</a><span class="link-target"> [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1]</span> in <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210">Programming with Objective-C</a><span class="link-target"> [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210]</span>. The example below exposes the getter for the <code class="docutils literal notranslate"><span class="pre">enabled</span></code> property of the <code class="docutils literal notranslate"><span class="pre">ExampleClass</span></code> to Objective-C code as <code class="docutils literal notranslate"><span class="pre">isEnabled</span></code> rather than just as the name of the property itself.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">ExampleClass</span>: <span class="nc">NSObject</span> {
</li><li>    <span class="k">@objc</span> <span class="k">var</span> <span class="nv">enabled</span>: <span class="nc">Bool</span> {
</li><li>        <span class="k">@objc(isEnabled)</span> <span class="k">get</span> {
</li><li>            <span class="c">// Return the appropriate value</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>For more information, see <a class="reference external" href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c">Importing Swift into Objective-C</a><span class="link-target"> [https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The argument to the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can also change the runtime name for that declaration. You use the runtime name when calling functions that interact with the Objective-C runtime, like <a class="reference external" href="https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring"><code class="docutils literal notranslate"><span class="pre">NSClassFromString</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring]</span>, and when specifying class names in an app’s Info.plist file. If you specify a name by passing an argument, that name is used as the name in Objective-C code and as the runtime name. If you omit the argument, the name used in Objective-C code matches the name in Swift code, and the runtime name follows the normal Swift compiler convention of name mangling.</p>
</div>
</div>
<div class="section" id="ID593">
<h3>objcMembers</h3>
<p>Apply this attribute to a class declaration, to implicitly apply the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to all Objective-C compatible members of the class, its extensions, its subclasses, and all of the extensions of its subclasses.</p>
<p>Most code should use the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute instead, to expose only the declarations that are needed. If you need to expose many declarations, you can group them in an extension that has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. The <code class="docutils literal notranslate"><span class="pre">objcMembers</span></code> attribute is a convenience for libraries that make heavy use of the introspection facilities of the Objective-C runtime. Applying the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute when it isn’t needed can increase your binary size and adversely affect performance.</p>
</div>
<div class="section" id="ID621">
<h3>propertyWrapper</h3>
<p>Apply this attribute to a class, structure, or enumeration declaration to use that type as a property wrapper. When you apply this attribute to a type, you create a custom attribute with the same name as the type. Apply that new attribute to a property of a class, structure, or enumeration to wrap access to the property through an instance of the wrapper type; apply the attribute to a local stored variable declaration to wrap access to the variable the same way. Computed variables, global variables, and constants can’t use property wrappers.</p>
<p>The wrapper must define a <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> instance property. The <em>wrapped value</em> of the property is the value that the getter and setter for this property expose. In most cases, <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> is a computed value, but it can be a stored value instead. The wrapper defines and manages any underlying storage needed by its wrapped value. The compiler synthesizes storage for the instance of the wrapper type by prefixing the name of the wrapped property with an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>)—for example, the wrapper for <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is stored as <code class="docutils literal notranslate"><span class="pre">_someProperty</span></code>. The synthesized storage for the wrapper has an access control level of <code class="docutils literal notranslate"><span class="pre">private</span></code>.</p>
<p>A property that has a property wrapper can include <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> blocks, but it can’t override the compiler-synthesized <code class="docutils literal notranslate"><span class="pre">get</span></code> or <code class="docutils literal notranslate"><span class="pre">set</span></code> blocks.</p>
<p>Swift provides two forms of syntactic sugar for initialization of a property wrapper. You can use assignment syntax in the definition of a wrapped value to pass the expression on the right-hand side of the assignment as the argument to the <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> parameter of the property wrapper’s initializer. You can also provide arguments to the attribute when you apply it to a property, and those arguments are passed to the property wrapper’s initializer. For example, in the code below, <code class="docutils literal notranslate"><span class="pre">SomeStruct</span></code> calls each of the initializers that <code class="docutils literal notranslate"><span class="pre">SomeWrapper</span></code> defines.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">propertyWrapper</span>
</li><li><span class="k">struct</span> <span class="nv">SomeWrapper</span> {
</li><li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span>
</li><li>    <span class="k">var</span> <span class="nv">someValue</span>: <span class="nc">Double</span>
</li><li>    <span class="k">init</span>() {
</li><li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="m">100</span>
</li><li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="m">12.3</span>
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">wrappedValue</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="nv">wrappedValue</span>
</li><li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="m">45.6</span>
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">wrappedValue</span> <span class="nv">value</span>: <span class="nc">Int</span>, <span class="nv">custom</span>: <span class="nc">Double</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="nv">value</span>
</li><li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="nv">custom</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li><li>    <span class="c">// Uses init()</span>
</li><li>    @<span class="nv">SomeWrapper</span> <span class="k">var</span> <span class="nv">a</span>: <span class="nc">Int</span>
</li><li>
</li><li>    <span class="c">// Uses init(wrappedValue:)</span>
</li><li>    @<span class="nv">SomeWrapper</span> <span class="k">var</span> <span class="nv">b</span> = <span class="m">10</span>
</li><li>
</li><li>    <span class="c">// Both use init(wrappedValue:custom:)</span>
</li><li>    @<span class="nv">SomeWrapper</span>(<span class="nv">custom</span>: <span class="m">98.7</span>) <span class="k">var</span> <span class="nv">c</span> = <span class="m">30</span>
</li><li>    @<span class="nv">SomeWrapper</span>(<span class="nv">wrappedValue</span>: <span class="m">30</span>, <span class="nv">custom</span>: <span class="m">98.7</span>) <span class="k">var</span> <span class="nv">d</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>projected value</em> for a wrapped property is a second value that a property wrapper can use to expose additional functionality. The author of a property wrapper type is responsible for determining the meaning of its projected value and defining the interface that the projected value exposes. To project a value from a property wrapper, define a <code class="docutils literal notranslate"><span class="pre">projectedValue</span></code> instance property on the wrapper type. The compiler synthesizes an identifier for the projected value by prefixing the name of the wrapped property with a dollar sign (<code class="docutils literal notranslate"><span class="pre">$</span></code>)—for example, the projected value for <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is <code class="docutils literal notranslate"><span class="pre">$someProperty</span></code>. The projected value has the same access control level as the original wrapped property.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">propertyWrapper</span>
</li><li><span class="k">struct</span> <span class="nv">WrapperWithProjection</span> {
</li><li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span>
</li><li>    <span class="k">var</span> <span class="nv">projectedValue</span>: <span class="nc">SomeProjection</span> {
</li><li>        <span class="k">return</span> <span class="nv">SomeProjection</span>(<span class="nv">wrapper</span>: <span class="k">self</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">SomeProjection</span> {
</li><li>    <span class="k">var</span> <span class="nv">wrapper</span>: <span class="nc">WrapperWithProjection</span>
</li><li>}
</li><li>
</li><li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li><li>    @<span class="nv">WrapperWithProjection</span> <span class="k">var</span> <span class="nv">x</span> = <span class="m">123</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">s</span> = <span class="nv">SomeStruct</span>()
</li><li><span class="nv">s</span>.<span class="nv">x</span>           <span class="c">// Int value</span>
</li><li><span class="nv">s</span>.<span class="nv">$x</span>          <span class="c">// SomeProjection value</span>
</li><li><span class="nv">s</span>.<span class="nv">$x</span>.<span class="nv">wrapper</span>  <span class="c">// WrapperWithProjection value</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID633">
<h3>resultBuilder</h3>
<p>Apply this attribute to a class, structure, enumeration to use that type as a result builder. A <em>result builder</em> is a type that builds a nested data structure step by step. You use result builders to implement a domain-specific language (DSL) for creating nested data structures in a natural, declarative way. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">resultBuilder</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/AdvancedOperators.xhtml#ID630"><span class="std std-ref">Result Builders</span></a>.</p>
<div class="section" id="ID634">
<h4>Result-Building Methods</h4>
<p>A result builder implements static methods described below. Because all of the result builder’s functionality is exposed through static methods, you don’t ever initialize an instance of that type. The <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method is required; the other methods—which enable additional functionality in the DSL—are optional. The declaration of a result builder type doesn’t actually have to include any protocol conformance.</p>
<p>The description of the static methods uses three types as placeholders. The type <code class="docutils literal notranslate"><span class="pre">Expression</span></code> is a placeholder for the type of the result builder’s input, <code class="docutils literal notranslate"><span class="pre">Component</span></code> is a placeholder for the type of a partial result, and <code class="docutils literal notranslate"><span class="pre">FinalResult</span></code> is a placeholder for the type of the result that the result builder produces. You replace these types with the actual types that your result builder uses. If your result-building methods don’t specify a type for <code class="docutils literal notranslate"><span class="pre">Expression</span></code> or <code class="docutils literal notranslate"><span class="pre">FinalResult</span></code>, they default to being the same as <code class="docutils literal notranslate"><span class="pre">Component</span></code>.</p>
<p>The result-building methods are as follows:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildBlock(_</span> <span class="pre">components:</span> <span class="pre">Component...)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Combines an array of partial results into a single partial result. A result builder must implement this method.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildOptional(_</span> <span class="pre">component:</span> <span class="pre">Component?)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result from a partial result that can be <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Implement this method to support <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that don’t include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildEither(first:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result whose value varies depending on some condition. Implement both this method and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> to support <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements and <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildEither(second:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result whose value varies depending on some condition. Implement both this method and <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> to support <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements and <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildArray(_</span> <span class="pre">components:</span> <span class="pre">[Component])</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result from an array of partial results. Implement this method to support <code class="docutils literal notranslate"><span class="pre">for</span></code> loops.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildExpression(_</span> <span class="pre">expression:</span> <span class="pre">Expression)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result from an expression. You can implement this method to perform preprocessing—for example, converting expressions to an internal type—or to provide additional information for type inference at use sites.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildFinalResult(_</span> <span class="pre">component:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">FinalResult</span></code></dt><dd><p>Builds a final result from a partial result. You can implement this method as part of a result builder that uses a different type for partial and final results, or to perform other postprocessing on a result before returning it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildLimitedAvailability(_</span> <span class="pre">component:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt><dd><p>Builds a partial result that propagates or erases type information outside a compiler-control statement that performs an availability check. You can use this to erase type information that varies between the conditional branches.</p>
</dd>
</dl>
<p>For example, the code below defines a simple result builder that builds an array of integers. This code defines <code class="docutils literal notranslate"><span class="pre">Component</span></code> and <code class="docutils literal notranslate"><span class="pre">Expression</span></code> as type aliases, to make it easier to match the examples below to the list of methods above.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">resultBuilder</span>
</li><li><span class="k">struct</span> <span class="nv">ArrayBuilder</span> {
</li><li>    <span class="k">typealias</span> <span class="nv">Component</span> = [<span class="nc">Int</span>]
</li><li>    <span class="k">typealias</span> <span class="nv">Expression</span> = <span class="nc">Int</span>
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildExpression</span>(<span class="k">_</span> <span class="nv">element</span>: <span class="nc">Expression</span>) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">return</span> [<span class="nv">element</span>]
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildOptional</span>(<span class="k">_</span> <span class="nv">component</span>: <span class="nc">Component</span>?) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">guard</span> <span class="k">let</span> <span class="nv">component</span> = <span class="nv">component</span> <span class="k">else</span> { <span class="k">return</span> [] }
</li><li>        <span class="k">return</span> <span class="nv">component</span>
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">first</span> <span class="nv">component</span>: <span class="nc">Component</span>) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">return</span> <span class="nv">component</span>
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">second</span> <span class="nv">component</span>: <span class="nc">Component</span>) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">return</span> <span class="nv">component</span>
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildArray</span>(<span class="k">_</span> <span class="nv">components</span>: [<span class="nc">Component</span>]) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">return</span> <span class="nv">Array</span>(<span class="nv">components</span>.<span class="nv">joined</span>())
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">Component</span>...) -&gt; <span class="nc">Component</span> {
</li><li>        <span class="k">return</span> <span class="nv">Array</span>(<span class="nv">components</span>.<span class="nv">joined</span>())
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID635">
<h4>Result Transformations</h4>
<p>The following syntactic transformations are applied recursively to turn code that uses result-builder syntax into code that calls the static methods of the result builder type:</p>
<ul>
<li><p>If the result builder has a <code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code> method, each expression becomes a call to that method. This transformation is always first. For example, the following declarations are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderNumber</span>: [<span class="nc">Int</span>] { <span class="m">10</span> }
</li><li><span class="k">var</span> <span class="nv">manualNumber</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">10</span>)
</li></ol></div></div></div>
</li>
<li><p>An assignment statement is transformed like an expression, but is understood to evaluate to <code class="docutils literal notranslate"><span class="pre">()</span></code>. You can define an overload of <code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code> that takes an argument of type <code class="docutils literal notranslate"><span class="pre">()</span></code> to handle assignments specifically.</p></li>
<li><p>A branch statement that checks an availability condition becomes a call to the <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method. This transformation happens before the transformation into a call to <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>, <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>, or <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>. You use the <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method to erase type information that changes depending on which branch is taken. For example, the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods below use a generic type that captures type information about both branches.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Drawable</span> {
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Text</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Line</span>&lt;<span class="nv">D</span>: <span class="nc">Drawable</span>&gt;: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">elements</span>: [<span class="nc">D</span>]
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="nv">elements</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">draw</span>() }.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">&quot;&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">DrawEither</span>&lt;<span class="nv">First</span>: <span class="nc">Drawable</span>, <span class="nv">Second</span>: <span class="nc">Drawable</span>&gt;: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>() }
</li><li>}
</li><li>
</li><li>@<span class="nv">resultBuilder</span>
</li><li><span class="k">struct</span> <span class="nv">DrawingBuilder</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>&lt;<span class="nv">D</span>: <span class="nc">Drawable</span>&gt;(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">D</span>...) -&gt; <span class="nc">Line</span>&lt;<span class="nc">D</span>&gt; {
</li><li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>&lt;<span class="nv">First</span>, <span class="nv">Second</span>&gt;(<span class="nv">first</span>: <span class="nc">First</span>)
</li><li>        -&gt; <span class="nc">DrawEither</span>&lt;<span class="nc">First</span>, <span class="nc">Second</span>&gt; {
</li><li>            <span class="k">return</span> <span class="nv">DrawEither</span>(<span class="nv">content</span>: <span class="nv">first</span>)
</li><li>    }
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>&lt;<span class="nv">First</span>, <span class="nv">Second</span>&gt;(<span class="nv">second</span>: <span class="nc">Second</span>)
</li><li>        -&gt; <span class="nc">DrawEither</span>&lt;<span class="nc">First</span>, <span class="nc">Second</span>&gt; {
</li><li>            <span class="k">return</span> <span class="nv">DrawEither</span>(<span class="nv">content</span>: <span class="nv">second</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>However, this approach causes a problem in code that has availability checks:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">@available</span>(<span class="k">macOS</span> <span class="m">99</span>, *)
</li><li><span class="k">struct</span> <span class="nv">FutureText</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li><li>}
</li><li>@<span class="nv">DrawingBuilder</span> <span class="k">var</span> <span class="nv">brokenDrawing</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">if</span> <span class="k">#available</span>(<span class="k">macOS</span> <span class="m">99</span>, *) {
</li><li>        <span class="nv">FutureText</span>(<span class="s">&quot;Inside.future&quot;</span>)  <span class="c">// Problem</span>
</li><li>    } <span class="k">else</span> {
</li><li>        <span class="nv">Text</span>(<span class="s">&quot;Inside.present&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="c">// The type of brokenDrawing is Line&lt;DrawEither&lt;Line&lt;FutureText&gt;, Line&lt;Text&gt;&gt;&gt;</span>
</li></ol></div></div></div>
<p>In the code above, <code class="docutils literal notranslate"><span class="pre">FutureText</span></code> appears as part of the type of <code class="docutils literal notranslate"><span class="pre">brokenDrawing</span></code> because it’s one of the types in the <code class="docutils literal notranslate"><span class="pre">DrawEither</span></code> generic type. This could cause your program to crash if <code class="docutils literal notranslate"><span class="pre">FutureText</span></code> isn’t available at runtime, even in the case where that type is explicitly not being used.</p>
<p>To solve this problem, implement a <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method to erase type information. For example, the code below builds an <code class="docutils literal notranslate"><span class="pre">AnyDrawable</span></code> value from its availability check.</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">AnyDrawable</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>() }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">DrawingBuilder</span> {
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildLimitedAvailability</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">AnyDrawable</span> {
</li><li>        <span class="k">return</span> <span class="nv">AnyDrawable</span>(<span class="nv">content</span>: <span class="nv">content</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li>@<span class="nv">DrawingBuilder</span> <span class="k">var</span> <span class="nv">typeErasedDrawing</span>: <span class="nc">Drawable</span> {
</li><li>    <span class="k">if</span> <span class="k">#available</span>(<span class="k">macOS</span> <span class="m">99</span>, *) {
</li><li>        <span class="nv">FutureText</span>(<span class="s">&quot;Inside.future&quot;</span>)
</li><li>    } <span class="k">else</span> {
</li><li>        <span class="nv">Text</span>(<span class="s">&quot;Inside.present&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="c">// The type of typeErasedDrawing is Line&lt;DrawEither&lt;AnyDrawable, Line&lt;Text&gt;&gt;&gt;</span>
</li></ol></div></div></div>
</li>
<li><p>A branch statement becomes a series of nested calls to the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods. The statements’ conditions and cases are mapped onto the leaf nodes of a binary tree, and the statement becomes a nested call to the <code class="docutils literal notranslate"><span class="pre">buildEither</span></code> methods following the path to that leaf node from the root node.</p>
<p>For example, if you write a switch statement that has three cases, the compiler uses a binary tree with three leaf nodes. Likewise, because the path from the root node to the second case is “second child” and then “first child”, that case becomes a nested call like <code class="docutils literal notranslate"><span class="pre">buildEither(first:</span> <span class="pre">buildEither(second:</span> <span class="pre">...</span> <span class="pre">))</span></code>. The following declarations are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someNumber</span> = <span class="m">19</span>
</li><li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderConditional</span>: [<span class="nc">Int</span>] {
</li><li>    <span class="k">if</span> <span class="nv">someNumber</span> &lt; <span class="m">12</span> {
</li><li>        <span class="m">31</span>
</li><li>    } <span class="k">else</span> <span class="k">if</span> <span class="nv">someNumber</span> == <span class="m">19</span> {
</li><li>        <span class="m">32</span>
</li><li>    } <span class="k">else</span> {
</li><li>        <span class="m">33</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">manualConditional</span>: [<span class="nc">Int</span>]
</li><li><span class="k">if</span> <span class="nv">someNumber</span> &lt; <span class="m">12</span> {
</li><li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">31</span>)
</li><li>    <span class="k">let</span> <span class="nv">outerPartialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">partialResult</span>)
</li><li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">outerPartialResult</span>)
</li><li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">someNumber</span> == <span class="m">19</span> {
</li><li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">32</span>)
</li><li>    <span class="k">let</span> <span class="nv">outerPartialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">partialResult</span>)
</li><li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">outerPartialResult</span>)
</li><li>} <span class="k">else</span> {
</li><li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">33</span>)
</li><li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">partialResult</span>)
</li><li>}
</li></ol></div></div></div>
</li>
<li><p>A branch statement that might not produce a value, like an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement without an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause, becomes a call to <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>. If the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement’s condition is satisfied, its code block is transformed and passed as the argument; otherwise, <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code> is called with <code class="docutils literal notranslate"><span class="pre">nil</span></code> as its argument. For example, the following declarations are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderOptional</span>: [<span class="nc">Int</span>] {
</li><li>    <span class="k">if</span> (<span class="nv">someNumber</span> % <span class="m">2</span>) == <span class="m">1</span> { <span class="m">20</span> }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">partialResult</span>: [<span class="nc">Int</span>]? = <span class="k">nil</span>
</li><li><span class="k">if</span> (<span class="nv">someNumber</span> % <span class="m">2</span>) == <span class="m">1</span> {
</li><li>    <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">20</span>)
</li><li>}
</li><li><span class="k">var</span> <span class="nv">manualOptional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildOptional</span>(<span class="nv">partialResult</span>)
</li></ol></div></div></div>
</li>
<li><p>A code block or <code class="docutils literal notranslate"><span class="pre">do</span></code> statement becomes a call to the <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method. Each of the statements inside of the block is transformed, one at a time, and they become the arguments to the <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method. For example, the following declarations are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderBlock</span>: [<span class="nc">Int</span>] {
</li><li>    <span class="m">100</span>
</li><li>    <span class="m">200</span>
</li><li>    <span class="m">300</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">manualBlock</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildBlock</span>(
</li><li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">100</span>),
</li><li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">200</span>),
</li><li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">300</span>)
</li><li>)
</li></ol></div></div></div>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">for</span></code> loop becomes a temporary variable, a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, and call to the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method. The new <code class="docutils literal notranslate"><span class="pre">for</span></code> loop iterates over the sequence and appends each partial result to that array. The temporary array is passed as the argument in the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> call. For example, the following declarations are equivalent:</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderArray</span>: [<span class="nc">Int</span>] {
</li><li>    <span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">5</span>...<span class="m">7</span> {
</li><li>        <span class="m">100</span> + <span class="nv">i</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">temporary</span>: [[<span class="nc">Int</span>]] = []
</li><li><span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">5</span>...<span class="m">7</span> {
</li><li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">100</span> + <span class="nv">i</span>)
</li><li>    <span class="nv">temporary</span>.<span class="nv">append</span>(<span class="nv">partialResult</span>)
</li><li>}
</li><li><span class="k">let</span> <span class="nv">manualArray</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildArray</span>(<span class="nv">temporary</span>)
</li></ol></div></div></div>
</li>
<li><p>If the result builder has a <code class="docutils literal notranslate"><span class="pre">buildFinalResult(_:)</span></code> method, the final result becomes a call to that method. This transformation is always last.</p></li>
</ul>
<p>Although the transformation behavior is described in terms of temporary variables, using a result builder doesn’t actually create any new declarations that are visible from the rest of your code.</p>
<p>You can’t use <code class="docutils literal notranslate"><span class="pre">break</span></code>, <code class="docutils literal notranslate"><span class="pre">continue</span></code>, <code class="docutils literal notranslate"><span class="pre">defer</span></code>, <code class="docutils literal notranslate"><span class="pre">guard</span></code>, or <code class="docutils literal notranslate"><span class="pre">return</span></code> statements, <code class="docutils literal notranslate"><span class="pre">while</span></code> statements, or <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statements in the code that a result builder transforms.</p>
<p>The transformation process doesn’t change declarations in the code, which lets you use temporary constants and variables to build up expressions piece by piece. It also doesn’t change <code class="docutils literal notranslate"><span class="pre">throw</span></code> statements, compile-time diagnostic statements, or closures that contain a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</p>
<p>Whenever possible, transformations are coalesced. For example, the expression <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span></code> becomes <code class="docutils literal notranslate"><span class="pre">buildExpression(4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6)</span></code> rather multiple calls to that function. Likewise, nested branch statements become a single binary tree of calls to the <code class="docutils literal notranslate"><span class="pre">buildEither</span></code> methods.</p>
</div>
<div class="section" id="ID636">
<h4>Custom Result-Builder Attributes</h4>
<p>Creating a result builder type creates a custom attribute with the same name. You can apply that attribute in the following places:</p>
<ul class="simple">
<li><p>On a function declaration, the result builder builds the body of the function.</p></li>
<li><p>On a variable or subscript declaration that includes a getter, the result builder builds the body of the getter.</p></li>
<li><p>On a parameter in a function declaration, the result builder builds the body of a closure that’s passed as the corresponding argument.</p></li>
</ul>
<p>Applying a result builder attribute doesn’t impact ABI compatibility. Applying a result builder attribute to a parameter makes that attribute part of the function’s interface, which can effect source compatibility.</p>
</div>
</div>
<div class="section" id="ID594">
<h3>requires_stored_property_inits</h3>
<p>Apply this attribute to a class declaration to require all stored properties within the class to provide default values as part of their definitions. This attribute is inferred for any class that inherits from <code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code>.</p>
</div>
<div class="section" id="ID595">
<h3>testable</h3>
<p>Apply this attribute to an <code class="docutils literal notranslate"><span class="pre">import</span></code> declaration to import that module with changes to its access control that simplify testing the module’s code. Entities in the imported module that are marked with the <code class="docutils literal notranslate"><span class="pre">internal</span></code> access-level modifier are imported as if they were declared with the <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier. Classes and class members that are marked with the <code class="docutils literal notranslate"><span class="pre">internal</span></code> or <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier are imported as if they were declared with the <code class="docutils literal notranslate"><span class="pre">open</span></code> access-level modifier. The imported module must be compiled with testing enabled.</p>
</div>
<div class="section" id="ID596">
<h3>UIApplicationMain</h3>
<p>Apply this attribute to a class to indicate that it’s the application delegate. Using this attribute is equivalent to calling the <code class="docutils literal notranslate"><span class="pre">UIApplicationMain</span></code> function and passing this class’s name as the name of the delegate class.</p>
<p>If you don’t use this attribute, supply a <code class="docutils literal notranslate"><span class="pre">main.swift</span></code> file with code at the top level that calls the <a class="reference external" href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain"><code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain]</span> function. For example, if your app uses a custom subclass of <code class="docutils literal notranslate"><span class="pre">UIApplication</span></code> as its principal class, call the <code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code> function instead of using this attribute.</p>
<p>The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.xhtml#ID352"><span class="std std-ref">Top-Level Code</span></a>.</p>
</div>
<div class="section" id="ID651">
<h3>unchecked</h3>
<p>Apply this attribute to a protocol type as part of a type declaration’s list of adopted protocols to turn off enforcement of that protocol’s requirements.</p>
<p>The only supported protocol is <a class="reference external" href="https://developer.apple.com/documentation/swift/sendable"><code class="docutils literal notranslate"><span class="pre">Sendable</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/sendable]</span>.</p>
</div>
<div class="section" id="ID597">
<h3>usableFromInline</h3>
<p>Apply this attribute to a function, method, computed property, subscript, initializer, or deinitializer declaration to allow that symbol to be used in inlinable code that’s defined in the same module as the declaration. The declaration must have the <code class="docutils literal notranslate"><span class="pre">internal</span></code> access-level modifier. A structure or class marked <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can use only types that are public or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> for its properties. An enumeration marked <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can use only types that are public or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> for the raw values and associated values of its cases.</p>
<p>Like the <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier, this attribute exposes the declaration as part of the module’s public interface. Unlike <code class="docutils literal notranslate"><span class="pre">public</span></code>, the compiler doesn’t allow declarations marked with <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> to be referenced by name in code outside the module, even though the declaration’s symbol is exported. However, code outside the module might still be able to interact with the declaration’s symbol by using runtime behavior.</p>
<p>Declarations marked with the <code class="docutils literal notranslate"><span class="pre">inlinable</span></code> attribute are implicitly usable from inlinable code. Although either <code class="docutils literal notranslate"><span class="pre">inlinable</span></code> or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can be applied to <code class="docutils literal notranslate"><span class="pre">internal</span></code> declarations, applying both attributes is an error.</p>
</div>
<div class="section" id="ID598">
<h3>warn_unqualified_access</h3>
<p>Apply this attribute to a top-level function, instance method, or class or static method to trigger warnings when that function or method is used without a preceding qualifier, such as a module name, type name, or instance variable or constant. Use this attribute to help discourage ambiguity between functions with the same name that are accessible from the same scope.</p>
<p>For example, the Swift standard library includes both a top-level <a class="reference external" href="https://developer.apple.com/documentation/swift/1538339-min/"><code class="docutils literal notranslate"><span class="pre">min(_:_:)</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/1538339-min/]</span> function and a <a class="reference external" href="https://developer.apple.com/documentation/swift/sequence/1641174-min"><code class="docutils literal notranslate"><span class="pre">min()</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/sequence/1641174-min]</span> method for sequences with comparable elements. The sequence method is declared with the <code class="docutils literal notranslate"><span class="pre">warn_unqualified_access</span></code> attribute to help reduce confusion when attempting to use one or the other from within a <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> extension.</p>
</div>
<div class="section" id="ID349">
<h3>Declaration Attributes Used by Interface Builder</h3>
<p>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode. Swift provides the following Interface Builder attributes: <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, and <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>. These attributes are conceptually the same as their Objective-C counterparts.</p>
<p>You apply the <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code> and <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code> attributes to property declarations of a class. You apply the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code> and <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code> attribute to method declarations of a class and the <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code> attribute to class declarations.</p>
<p>Applying the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, or <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code> attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</p>
</div>
</div>
<div class="section" id="ID350">
<h2>Type Attributes</h2>
<p>You can apply type attributes to types only.</p>
<div class="section" id="ID599">
<h3>autoclosure</h3>
<p>Apply this attribute to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments. You apply it to a parameter’s type in a function or method declaration, for a parameter whose type is a function type that takes no arguments and that returns a value of the type of the expression. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">autoclosure</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/Closures.xhtml#ID543"><span class="std std-ref">Autoclosures</span></a> and <a class="reference internal" href="Types.xhtml#ID449"><span class="std std-ref">Function Type</span></a>.</p>
</div>
<div class="section" id="ID600">
<h3>convention</h3>
<p>Apply this attribute to the type of a function to indicate its calling conventions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">convention</span></code> attribute always appears with one of the following arguments:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">swift</span></code> argument indicates a Swift function reference. This is the standard calling convention for function values in Swift.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">block</span></code> argument indicates an Objective-C compatible block reference. The function value is represented as a reference to the block object, which is an <code class="docutils literal notranslate"><span class="pre">id</span></code>-compatible Objective-C object that embeds its invocation function within the object. The invocation function uses the C calling convention.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">c</span></code> argument indicates a C function reference. The function value carries no context and uses the C calling convention.</p></li>
</ul>
<p>With a few exceptions, a function of any calling convention can be used when a function any other calling convention is needed. A nongeneric global function, a local function that doesn’t capture any local variables, or a closure that doesn’t capture any local variables can be converted to the C calling convention. Other Swift functions can’t be converted to the C calling convention. A function with the Objective-C block calling convention can’t be converted to the C calling convention.</p>
</div>
<div class="section" id="ID601">
<h3>escaping</h3>
<p>Apply this attribute to a parameter’s type in a function or method declaration to indicate that the parameter’s value can be stored for later execution. This means that the value is allowed to outlive the lifetime of the call. Function type parameters with the <code class="docutils literal notranslate"><span class="pre">escaping</span></code> type attribute require explicit use of <code class="docutils literal notranslate"><span class="pre">self.</span></code> for properties or methods. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">escaping</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/Closures.xhtml#ID546"><span class="std std-ref">Escaping Closures</span></a>.</p>
</div>
<div class="section" id="ID652">
<h3>Sendable</h3>
<p>Apply this attribute to the type of a function to indicate that the function or closure is sendable. Applying this attribute to a function type has the same meaning as conforming a non–function type to the <a class="reference external" href="https://developer.apple.com/documentation/swift/sendable"><code class="docutils literal notranslate"><span class="pre">Sendable</span></code></a><span class="link-target"> [https://developer.apple.com/documentation/swift/sendable]</span> protocol.</p>
<p>This attribute is inferred on functions and closures if the function or closure is used in a context that expects a sendable value, and the function or closure satisfies the requirements to be sendable.</p>
<p>A sendable function type is a subtype of the corresponding nonsendable function type.</p>
</div>
</div>
<div class="section" id="ID604">
<h2>Switch Case Attributes</h2>
<p>You can apply switch case attributes to switch cases only.</p>
<div class="section" id="ID605">
<h3>unknown</h3>
<p>Apply this attribute to a switch case to indicate that it isn’t expected to be matched by any case of the enumeration that’s known at the time the code is compiled. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">unknown</span></code> attribute, see <a class="reference internal" href="Statements.xhtml#ID602"><span class="std std-ref">Switching Over Future Enumeration Cases</span></a>.</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an attribute</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute"></a>attribute</span><span class="arrow"> → </span> <code>&#64;</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_attribute-name">attribute-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_attribute-argument-clause">attribute-argument-clause</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute-name"></a>attribute-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.xhtml#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute-argument-clause"></a>attribute-argument-clause</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attributes"></a>attributes</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_attribute">attribute</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_attributes">attributes</a></span> <sub>opt</sub></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-tokens"></a>balanced-tokens</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-token">balanced-token</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token"></a>balanced-token</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1004"></a>balanced-token</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1005"></a>balanced-token</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.xhtml#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1006"></a>balanced-token</span><span class="arrow"> → </span> Any identifier, keyword, literal, or operator</p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1007"></a>balanced-token</span><span class="arrow"> → </span> Any punctuation except  <code>(</code>,  <code>)</code>,  <code>[</code>,  <code>]</code>,  <code>{</code>, or  <code>}</code></p></div></div></div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>